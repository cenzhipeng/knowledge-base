---
id: 函数
title: 本文内容
sidebar_label: 函数
---



## callable

判断某个对象是否可调用

```
def a():
    pass


print(callable(a))

True
```



## 创建函数

```
def a():
    return 3
```

### 函数文档

放在函数开头的字符串称为 文档字符串(docstring)，将作为函数的一部分存储起来

```
def a():
    """
    测试用的函数
    :return:
    """
    pass


print(a.__doc__)
```

> 使用 `a.__doc__` 可以访问这个函数文档

### 返回值

所有的函数都返回值。如果你没有告诉它们该返回什么，将返回None



## 参数

### 位置参数

```
def func1(para1, para2, para3):
    print(para1, para2, para3)


func1(2, 3, 5)

输出：2 3 5
```

形如这种参数叫做位置参数，就是最普通的一种函数参数

### 关键字参数（命名参数）

```
def func1(para1, para2, para3):
    print(para1, para2, para3)


func1(para2=2, para3=3, para1=5)

输出：5 2 3
```

形如这种传参的方式叫做关键字参数。我们可以不按照函数的参数定义顺序来传参

### 参数默认值

```
def func1(para1=3, para2=6, para3=9):
    print(para1, para2, para3)


func1(para2=2, para3=3)

输出：3 2 3
```

形如这种函数定义给了参数一个默认值

> 带有默认值的参数定义必须在没有默认值参数的后面也就是说，para3 必须带有默认值，否则应该放在参数列表的前面

### 混合传参

我们既可以使用位置参数也可以使用关键字参数

```
def func1(para1=3, para2=6, para3=9):
    print(para1, para2, para3)


func1(5, para2=2, para3=3)

输出：5 2 3
```

> 这种方式，需要先给出位置参数，然后给出命名参数

### 收集参数

```
def func1(*params):
    print(params)


func1(1, 2, 3)

输出：(1, 2, 3)
```

> 这种参数就类似于是一个解构（实际上这种解构并不合法）：
>
> `*params = 1, 2, 3`
>
> params 类型将是 tuple

```
def func1(a, *params):
    print(a, params)


func1(1, 2, 3, 4, 5)

输出：1 (2, 3, 4, 5)
```

> 这种带星号的参数放在参数列表的最后，用来接收剩下所有的参数。如果没有剩余的参数，将是一个空元组

实际来说，带星号的接收参数也可以不放在最后，这样的情况下，我们必须使用**关键字传参**的方式传递参数

```
def func1(a, *params, b):
    print(a, params, b)


func1(1, 2, 3, 4, 5)
# 抛异常
```

```
def func1(a, *params, b):
    print(a, params, b)


func1(1, 2, 3, 4, b=5)

输出：1 (2, 3, 4) 5
```

#### 收集多余的关键字参数（双星号）

```
def func1(a, *params):
    print(a, params)


func1(1, 2, 3, 4, b=5)
# 抛异常
```

我们多传递了一个不存在的关键字，会抛出异常

```
def func1(a, m=7, *params, **args):
    print(a, m, params, args)


func1(1, 2, 3, 4, b=5, c=7)

输出：1 2 (3, 4) {'b': 5, 'c': 7}
```

> - params 接收所有的剩余参数（不含关键字参数），因此是 3，4 元组
> - args 接收所有的剩余关键字参数，因此是字典 {'b': 5, 'c': 7}

### 参数展开

#### 列表和元组展开

有时候，我们有一个列表或者元组和字典，需要将其展开为多个参数传递给函数，可以使用如下方式

```
def add(a, b):
    print(a + b)


m = [2, 4]
add(*m)

输出：6
```

如上所示，使用 `*m` 这种方式，就可以将参数展开，我们使用 `add(*[2, 4])` 就等价于调用了 `add(2, 4)` ，也就是被展开了一层的多个参数

#### 字典展开

字典展开需要使用双星号（传递的都是关键字参数）

```
def add(a, b):
    print(a + b)


m = {'a': 3, 'b': 5}
add(**m)

输出：8
```

这相当于是调用了 `add(a=3, b=5)`



## 作用域

### 内置字典

每个作用域都有一个内置字典，用状态机的理论来说就是：当前的状态。可以使用 vars 来返回这个字典

```
a = 5
b = "sss"
print(vars()['a'], vars()['b'])

输出：5 sss
```

> vars() 内置函数输出的是这个内置字典
>
> 除全局作用域外， 每个函数调用都将创建一个作用域：栈帧退出时作用域销毁（返回闭包时除外，作用域被捕获）

### 访问外部变量

python 的执行模型可以看做是：执行全局 main 函数，然后不断进入新的内部作用域（函数调用），内层的函数可以访问外层函数的变量（外部作用域），例如：

```
def a():
    m = 3

    def b(x):
        print(x + m)

    b(5)


a()

输出：8
```

### 变量遮蔽

向上面这种访问外部作用域的情况，可能会发生变量遮蔽

```
def a():
    m = 3

    def b(x):
        m = 2
        print(x + m)

    b(5)
    print(m)


a()


输出：7 和 3
```

> 这里表示 b 访问的是自己内部的 m = 2，没有访问到外部的 m = 3

我们可以使用 nonlocal 访问外部作用域的变量

```
def a():
    m = 3

    def b(x):
        nonlocal m
        m = 2
        print(x + m)

    b(5)
    print(m)


a()

输出：7 和 2
```

输出证明 a 方法内部的 m 确实被 b 方法给改动了，这个用法很不常用，了解即可

同理还有 global 关键字，可以访问本模块的全局变量





