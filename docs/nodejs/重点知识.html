<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要是记录一些重点知识，包括原型链、NEW 运算符，this 引用等"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要是记录一些重点知识，包括原型链、NEW 运算符，this 引用等"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/docusaurus/快速开始/install" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Node JS</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Docusaurus<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/install">安装运行</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/config">目录结构和配置</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/build">构建并发布到 Github Pages</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node JS<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/重点知识.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要是记录一些重点知识，包括原型链、NEW 运算符，this 引用等</p>
<h2><a class="anchor" aria-hidden="true" id="原型链"></a><a href="#原型链" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原型链</h2>
<p>记住以下 2 条即可：</p>
<ul>
<li><p>JavaScript 对象有一个指向一个原型对象的引用(称之为 <code>__proto__</code>)。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型对象，以及该对象的原型对象的原型对象，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾（一直找到 Object 到 null）。例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> obj1 = {
    <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'obj1'</span>;
    }
};
<span class="hljs-keyword">var</span> obj2 = {
    <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'obj2'</span>;
    }
};
<span class="hljs-keyword">var</span> obj3 = {
    <span class="hljs-attr">z</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'obj3'</span>;
    },
    <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">if</span> (x !== <span class="hljs-string">'name'</span> &amp;&amp; x !== <span class="hljs-string">'toString'</span>) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Object: '</span> + <span class="hljs-keyword">this</span>.name() + <span class="hljs-string">', '</span> + x + <span class="hljs-string">': '</span> + <span class="hljs-keyword">this</span>[x]);
            }
        }
    }
};
obj1.__proto__ = obj2;
obj2.__proto__ = obj3;
<span class="hljs-comment">// 经过以上操作，现在 obj1 的原型对象是 obj2，obj2 的原型对象是 obj3</span>
<span class="hljs-comment">// 因此 obj1 拥有 obj2 和 obj3 的属性 y 和 z，obj2 拥有 obj3 的属性 z</span>
obj1.toString();
obj2.toString();
obj3.toString();
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">// Object: obj1, x: 1</span>
<span class="hljs-comment">// Object: obj1, y: 2</span>
<span class="hljs-comment">// Object: obj1, z: 3</span>
<span class="hljs-comment">// Object: obj2, y: 2</span>
<span class="hljs-comment">// Object: obj2, z: 3</span>
<span class="hljs-comment">// Object: obj3, z: 3</span>
</code></pre>
<blockquote>
<p>注意：</p>
<p><code>__proto__</code> 不是一个标准属性，但是许多 JS 环境都实现了该属性。</p>
<p>从 ES 6 开始，我们可以通过 <code>Object.getPrototypeOf(obj)</code> 和 <code>Object.setPrototypeOf(obj)</code> 来访问一个对象的原型对象，这个等同于非标准实现的对象的 <code>__proto__</code> 属性。</p>
<p>为了避免混淆，本文就一直使用 <code>__proto__</code> 来代表一个对象的原型对象。</p>
<p>千万注意 <code>__proto__</code> 和下文要讲的 <code>prototype</code> 属性是两个完全不同的属性</p>
</blockquote></li>
</ul>
<ul>
<li><p>被构造函数创建的<strong>实例对象</strong>的 <code>___proto__</code> 指向这个<strong>构造函数</strong>的 <code>prototype</code> 属性，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{ }
<span class="hljs-comment">/**
 * a 对象(函数也是个对象)的原型现在是这个 { x: 3 } 对象
 * 因此 a.x = 3
 */</span>
a.__proto__ = { <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> };

a.prototype.x = <span class="hljs-number">5</span>; <span class="hljs-comment">// 将 a 的 prototype 属性对象，添加一个属性 x = 5</span>

<span class="hljs-comment">/**
 * 由构造函数(a 对象)生成的对象，它的原型对象等于构造函数对象的 prototype 属性
 * 也就是说 b.__proto__ === a.prototype 此时是成立的
 * 如果我调用 a.prototype = otherObj，直接修改指针指向的话
 * 那么 b.__proto__ === a.prototype 这个等式就不成立了
 */</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> a();

<span class="hljs-built_in">console</span>.log(a.x); <span class="hljs-comment">// a.x = a.__proto__.x = 3</span>
<span class="hljs-comment">/**
 * b.x = b.__proto__.x = a.prototype.x = 5
 * 记住（b.__proto__ === a.prototype）
 */</span>
<span class="hljs-built_in">console</span>.log(b.x); 
</code></pre>
<p>也可以这么说：只有构造函数对象的 <code>prototype</code> 属性才是有意义的，普通对象的 <code>prototype</code> 属性没有其它的含义（暂时理解是这样），而所有对象（包括构造函数对象）的 <code>___proto__</code> 属性都指向了这个对象本身的原型对象。</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="this-引用规则"></a><a href="#this-引用规则" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>this 引用规则</h2>
<p><strong>最外层代码中，this 引用的是全局对象（非模块化的情况下，在 node 中无法还原 <code>this === global</code>，在浏览器环境中有 <code>this === window</code>）</strong></p>
<p>在函数内，this 引用根据 <strong>函数调用方式</strong> 具有不同的指向：</p>
<table>
<thead>
<tr><th>函数的调用方式</th><th>this 引用的引用对象</th></tr>
</thead>
<tbody>
<tr><td>构造函数调用</td><td>构造的新对象</td></tr>
<tr><td>方法调用</td><td>接收方对象，例如 <code>obj.method()</code>指向 <code>obj</code></td></tr>
<tr><td>apply 或是 call 调用</td><td>由 apply 或 call 的参数指定的对象</td></tr>
<tr><td>其他方式的调用</td><td>全局对象</td></tr>
</tbody>
</table>
<p>接收方对象的示例：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">doit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'method is called.'</span> + <span class="hljs-keyword">this</span>.x);
        <span class="hljs-keyword">var</span> innerObj = {
            <span class="hljs-attr">x</span>: <span class="hljs-number">20</span>,
            <span class="hljs-attr">inner</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'inner method is called.'</span> + <span class="hljs-keyword">this</span>.x);
            }
        }
        innerObj.inner();
    }
}
obj.doit();
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">// method is called.100</span>
<span class="hljs-comment">// inner method is called.20</span>
</code></pre>
<p>进一步说明接收方的概念（以下示例是跑在 node 环境中，所以全局对象是 <code>global</code>）：</p>
<pre><code class="hljs css language-javascript">global.x = <span class="hljs-number">3</span>; <span class="hljs-comment">// 给全局对象添加属性 x = 3</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">doit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'method is called.'</span> + <span class="hljs-keyword">this</span>.x);
    }
}
obj.doit(); <span class="hljs-comment">// 接收方是 obj，所以输出的是 obj.x = 100</span>
<span class="hljs-keyword">var</span> tmp = obj.doit;
tmp(); <span class="hljs-comment">// 没有接收方，this 指向全局对象 global，所以输出的是 global.x = 3;</span>
</code></pre>
<p><strong>也就是说形如 <code>obj.method()</code> 的调用方式，接收方就是 <code>obj</code></strong></p>
<h2><a class="anchor" aria-hidden="true" id="apply-与-call"></a><a href="#apply-与-call" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>apply 与 call</h2>
<p>通过 apply 与 call 调用的函数的 this 引用可以指向任意对象。也就是说，它们可以显式地指定接收对象，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x);
}
<span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">4</span> };
f.apply(obj); <span class="hljs-comment">// 指定此次调用中，f指向的接收对象是 obj，因此输出 obj.x = 4</span>
f.call(obj); <span class="hljs-comment">// 指定此次调用中，f指向的接收对象是 obj，因此输出 obj.x = 4</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">doit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'method is called.'</span> + <span class="hljs-keyword">this</span>.x);
    }
};
<span class="hljs-keyword">var</span> obj2 = { <span class="hljs-attr">x</span>: <span class="hljs-number">5</span> };
obj.doit.apply(obj2); <span class="hljs-comment">// 指定此次调用中，f指向的接收对象是 obj2，因此输出 obj2.x = 5</span>
</code></pre>
<p>两种方法的第一个参数都是接收方对象，两种方式的区别仅仅在于后续传递参数的方式，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this.x = '</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">', a = '</span> + a + <span class="hljs-string">', b = '</span> + b);
}
f.apply({ <span class="hljs-attr">x</span>: <span class="hljs-number">4</span> }, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// apply 后续参数需要使用数组传递 [1,2]</span>
f.call({ <span class="hljs-attr">x</span>: <span class="hljs-number">4</span> }, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// call 后续参数按照原来参数的顺序进行传递 1,2</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="new-运算符"></a><a href="#new-运算符" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NEW 运算符</h2>
<p>MDN 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">NEW 运算符</a></p>
<p><code>new</code> 运算符会进行如下操作：</p>
<ol>
<li>创建一个空的简单 <code>JavaScript</code> 对象，也就是 <code>{}</code>，假设起一个临时名字是 <code>tmp</code></li>
<li>将新对象 <code>tmp</code> 的原型对象指向构造函数（假设是 <code>Func()</code> 函数）的 <code>prototype</code> 属性，也就是说 <code>tmp.__proto__ = Func.prototype</code></li>
<li>此时 <code>tmp.constructor = Func.prototype.constructor = Func</code></li>
<li>步骤 3 有两个关键，一个是 <code>tmp.constructor = Func</code>，一个是 <code>Func.prototype.constructor = Func</code>
<ul>
<li>也就是说新对象的 <code>constructor</code>是从原型链继承来的</li>
<li>函数对象的 <code>prototype</code> 属性上，有一个属性 <code>prototype.constructor</code> 指向函数对象自身</li>
</ul></li>
<li>调用新对象的 <code>constructor</code> 方法，也就是 <code>tmp.constructor(...)</code></li>
<li>步骤 5 的接收对象是 <code>tmp</code>，因此构造函数中 <code>this</code> 指向 <code>tmp</code></li>
<li>如果 <code>tmp.constructor(...)</code> 没有返回新对象，则返回 <code>this</code>，也就是 <code>tmp</code> 对象</li>
<li><code>new Func</code> 等同于 <code>new Func()</code>，也就是进行没有任何参数的构造函数调用</li>
</ol>
<p>示例：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">arg</span>) </span>{ <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>; <span class="hljs-built_in">console</span>.log(arg); }
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> a(); <span class="hljs-comment">// 输出 undefined</span>

<span class="hljs-comment">/**
 * b.constructor = b.__proto__.constructor 且 b.__proto__ = a.prototype
 * 因此 b.__proto__.constructor = a.prototype.constructor
 * 而 a.prototype.constructor = a 自身
 * 所以 b.constructor = a
 * 这里输出 [Function: a]
 */</span>
<span class="hljs-built_in">console</span>.log(b.constructor); 

b.__proto__ = <span class="hljs-built_in">Object</span>.prototype;

<span class="hljs-comment">/**
 * 此时 b.constructor = b.__proto__.constructor = Object.prototype.constructor
 * 因此 b.constructor = Object
 * 所以输出 [Function: Object]
 */</span>
<span class="hljs-built_in">console</span>.log(b.constructor);

a.prototype.constructor(<span class="hljs-number">11111</span>); <span class="hljs-comment">// 等价于 a(11111)调用，因此输出 11111</span>

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="元属性（属性描述符）"></a><a href="#元属性（属性描述符）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元属性（属性描述符）</h2>
<p>从 ES 5 开始，所有属性都有属性描述符，参考下面的代码：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> myObject = { <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="hljs-string">"a"</span>));
</code></pre>
<p>它的输出是：</p>
<pre><code class="hljs css language-javascript">{ <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span> }
</code></pre>
<p>这就是 <code>myObject.a</code> 这个属性的描述符，也就是描述这个属性的属性，我将它称为元属性。（所谓元属性就是描述一个属性本身应该有哪些属性，例如我们的数据库，数据库里存的记录是<strong>数据</strong>，而描述这些记录的记录是元数据，例如数据库表的定义，描述一个表应该有哪些字段，字段应该是什么类型，这就是元数据）</p>
<p>在创建普通属性时，属性描述符会使用默认值，我们也可以用 <code>Object.defineProperty(..)</code> 来添加一个新属性或者修改已有属性（如果它是 <code>configurable</code>），例如：</p>
<pre><code class="hljs"><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> <span class="hljs-string">{};</span>
<span class="hljs-string">Object.defineProperty(myObject,</span> <span class="hljs-string">"a"</span><span class="hljs-string">,</span> <span class="hljs-string">{</span>
    <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span>
    <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
    <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
    <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span>
<span class="hljs-string">});</span>
<span class="hljs-string">console.log(myObject.a);</span> <span class="hljs-string">//</span> <span class="hljs-number">2</span>
</code></pre>
<p>在 ES 标准中，属性有 2 种类型，一种是数据属性，一种是访问器属性</p>
<ul>
<li>数据属性的属性描述符包含有 4 种属性，分别是 value、writable、configurable、enumerable</li>
<li>访问器属性的属性描述符包含有 4 种属性，分别是 configurable、enumerable、get、set</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="数据属性"></a><a href="#数据属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据属性</h3>
<h4><a class="anchor" aria-hidden="true" id="writable"></a><a href="#writable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writable</h4>
<p><code>Writable</code> 决定是否可以修改属性的值，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> myObject = {};
<span class="hljs-built_in">Object</span>.defineProperty(myObject, <span class="hljs-string">"a"</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！ </span>
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});
myObject.a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 这里修改 myObject.a 将会失败</span>
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 2</span>
</code></pre>
<p>在严格模式（&quot;use strict&quot;;）下，甚至会报错。说白了这个元属性类似于 java 的 final 修饰符</p>
<p>默认值：true</p>
<h4><a class="anchor" aria-hidden="true" id="configurable"></a><a href="#configurable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configurable</h4>
<p><code>Configurable</code> 决定我们是否可以用 <code>defineProperty(..)</code> 方法来修改元属性，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> myObject = { <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> };
myObject.a = <span class="hljs-number">3</span>;
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">Object</span>.defineProperty(myObject, <span class="hljs-string">"a"</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可配置！</span>
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 4 </span>
myObject.a = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">Object</span>.defineProperty(myObject, <span class="hljs-string">"a"</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
}); <span class="hljs-comment">// TypeError</span>
</code></pre>
<p>不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。这个元属性决定了我们是否能继续修改这些元属性，所以一旦为 false，就永远不能撤销了</p>
<p>除了无法修改元属性之外，这个属性本身也无法被删除了，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> myObject = { <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> };
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 2</span>
<span class="hljs-keyword">delete</span> myObject.a;
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.defineProperty(myObject, <span class="hljs-string">"a"</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 5 </span>
<span class="hljs-keyword">delete</span> myObject.a; <span class="hljs-comment">// 静默失败</span>
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">// 5</span>
</code></pre>
<p>默认值：true</p>
<h4><a class="anchor" aria-hidden="true" id="enumerable"></a><a href="#enumerable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enumerable</h4>
<p>这个描述符控制的是属性是否会出现在对象的属性枚举中， 比如说 <code>for..in</code> 循环。 如果把 enumerable 设置成 false ， 这个属性就不会出现在枚举中。</p>
<p>默认值：true</p>
<h4><a class="anchor" aria-hidden="true" id="value"></a><a href="#value" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Value</h4>
<p>包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。</p>
<p>从上文可以看出，这个元属性代表了属性的值。</p>
<p>默认值：undefined</p>
<h3><a class="anchor" aria-hidden="true" id="访问器属性"></a><a href="#访问器属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问器属性</h3>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。 在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。</p>
<h4><a class="anchor" aria-hidden="true" id="configurable-1"></a><a href="#configurable-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>configurable</h4>
<p>同数据属性的 configurable 元属性</p>
<h4><a class="anchor" aria-hidden="true" id="enumerable-1"></a><a href="#enumerable-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>enumerable</h4>
<p>同数据属性的 enumerable 元属性</p>
<h4><a class="anchor" aria-hidden="true" id="get-（es-6-之后的语法）"></a><a href="#get-（es-6-之后的语法）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>get （ES 6 之后的语法）</h4>
<p>在读取数据值时会被调用的函数，类似于 java 里的 getter 方法，只不过 JS 里定义 get 之后，我们可以直接用属性名称来代替 get 方法的调用，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">log</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>],
    <span class="hljs-keyword">get</span> latest() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.log.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.log[<span class="hljs-keyword">this</span>.log.length - <span class="hljs-number">1</span>];
    }
}

<span class="hljs-built_in">console</span>.log(obj.latest);
  <span class="hljs-comment">// expected output: "c"</span>
</code></pre>
<p>如果在 ES 6 之前的话，我们只能使用 <code>Object.defineProperty</code> 来定义访问器属性</p>
<p>访问器属性 get 注意以下问题</p>
<ul>
<li>可以使用数值或字符串作为标识，也就是例如 latest 方法，可以改成 <code>get 1()</code>，然后使用 <code>obj[1]</code> 进行访问这个属性</li>
<li>必须不带参数</li>
<li>相同属性不能定义多个 get 方法，而且如果该属性有 value 了，不能定义 get 方法</li>
<li>当只是指定了 get，没有指定 set 的时候，表示这个值是只写的，尝试写入会静默失败，在严格模式下会报错</li>
</ul>
<p>作用和技巧：</p>
<ul>
<li><p>当属性计算比较复杂时，用到的时候才计算这个属性</p></li>
<li><p>当属性计算很耗费资源的时候，我们可以先定义 get 方法，使用一次去获取属性值之后，再将其删除，然后添加成数据属性，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">get</span> notifier() {
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.notifier;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.notifier = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'bookmarked-notification-anchor'</span>);
},
<span class="hljs-comment">// 上面先是定义成 get，然后再方法里就将其定义成了数据属性，这样可以延迟计算</span>
</code></pre></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="set"></a><a href="#set" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>set</h4>
<p>当尝试设置属性时，<strong><code>set</code></strong>语法将对象属性绑定到要调用的函数，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> language = {
    <span class="hljs-keyword">set</span> current(name) {
        <span class="hljs-keyword">this</span>.log.push(name);
    },
    <span class="hljs-attr">log</span>: []
}

language.current = <span class="hljs-string">'EN'</span>;
language.current = <span class="hljs-string">'FA'</span>;

<span class="hljs-built_in">console</span>.log(language.log);
  <span class="hljs-comment">// expected output: Array ["EN", "FA"]</span>
</code></pre>
<p>说白了还是类似于 java 的 get/set 机制。明显来说，当我们定义了一对 get/set 的时候，将相当于定义了一个伪属性，该属性可以读写，跟数据属性很相似。</p>
<p>使用 set 时需要注意以下问题：</p>
<ul>
<li>可以使用数值或字符串作为标识，同上方列举的 get 的注意点的第一条</li>
<li>它必须有一个明确的参数，实际上就是我们赋值的那个值会作为参数</li>
<li>不能为一个已有真实值的变量使用 set，也不能为同一个属性设置多个 set（稍微思考下就知道这个是必然的）</li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/1/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/常用API"><span class="arrow-prev">← </span><span>常用 API</span></a><a class="docs-next button" href="/docs/doc3"><span>Next</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#原型链">原型链</a></li><li><a href="#this-引用规则">this 引用规则</a></li><li><a href="#apply-与-call">apply 与 call</a></li><li><a href="#new-运算符">NEW 运算符</a></li><li><a href="#元属性（属性描述符）">元属性（属性描述符）</a><ul class="toc-headings"><li><a href="#数据属性">数据属性</a></li><li><a href="#访问器属性">访问器属性</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>