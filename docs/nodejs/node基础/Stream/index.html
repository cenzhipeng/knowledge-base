<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要记录关于 node 中的流的一些内容。有关更详细的内容，请参考博客里 `stream系列` 的内容"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要记录关于 node 中的流的一些内容。有关更详细的内容，请参考博客里 `stream系列` 的内容"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Node 基础</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JVM系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/JVM系列/JVM内存区域">JVM内存区域</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/对象创建-布局-访问">对象创建-布局-访问</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存溢出实战">内存溢出实战</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存区域回收">内存区域回收</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/四大引用">四大引用</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/垃圾回收算法">垃圾回收算法</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/HotSpot回收算法细节">HotSpot回收算法细节</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/块级作用域">块级作用域</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/字符串和正则表达式">字符串和正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/对象">对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Symbol">Symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Set和Map">Set和Map</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/迭代器和生成器">迭代器和生成器</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/类">类</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/数组">数组</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Promise">Promise</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/node基础/Stream.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要记录关于 node 中的流的一些内容。有关更详细的内容，请参考博客里 <code>stream系列</code> 的内容</p>
<h2><a class="anchor" aria-hidden="true" id="什么是流"></a><a href="#什么是流" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是流</h2>
<p>可以把一个流当成是一个具有方向的管道。</p>
<p>想想我们的 UNIX 进程的标准，规定一个进程有 3 个流，分别是标准输入、标准输出、标准错误。对于一个进程来说，标准输入是可以读取的流，标准输出和标准错误都是可以写入的流。</p>
<p>我们来想一想我们不使用流的时候，最简单的读取和写入（伪代码）：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// 读取文件</span>
<span class="hljs-keyword">var</span> content = read(xxxFile);
<span class="hljs-comment">//输出内容</span>
<span class="hljs-built_in">console</span>.log(content);
</code></pre>
<p>这段代码当然很直观，读取文件，并且输出到控制台(标准输出)，但是有一些问题：</p>
<ul>
<li><strong>必须一次读完和写完所有的内容</strong>：从 API 也能看出来，当我们读取时，必须把内容全部读完才能返回，当输出时也是一次性输出所有内容。那么当文件较大时，可能就会读取很久，表现就是进程暂时卡住一段时间，然后又是输出很久，表现也是进程卡住一段时间。</li>
<li><strong>读取大文件时内存占用爆炸</strong>：这个也很明显了，<code>content</code> 就是文件的整个内容，相当于整个文件都加载进了内存，万一是个大文件，几个 G 甚至更高的，内存直接就撑爆炸了</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="流和缓冲区"></a><a href="#流和缓冲区" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流和缓冲区</h2>
<p>那么使用流的话，是怎么解决上面的问题呢，答案就是缓冲区（Buffer）。</p>
<p>使用流的时候，我们每次读取一小部分，读取了之后就进行处理（输出），处理完毕之后接着读后续的部分，这样就保证了我们不需要一次读完所有内容，并且内存占用仅仅是缓冲区的大小，不论是多大的文件都可以正常工作。例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> rs = fs.createReadStream(<span class="hljs-string">'test.md'</span>);
rs.on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>)</span>{
        <span class="hljs-built_in">console</span>.log(chunk); 
}); 
<span class="hljs-comment">// 注意：本段代码只能读取单字节编码，例如 ascii</span>
<span class="hljs-comment">// 如果包含中文这种多字节编码的，可能会输出乱码</span>
</code></pre>
<p>可读流和可写流内部都有一个缓冲区 BufferList，可以分别使用的 <code>writable.writableBuffer</code> 或 <code>readable.readableBuffer</code> 来获取。这两个属性都是一个 <code>BufferList</code>，当我们在底层读取或者写入时，<code>highWaterMark</code> 的大小实际上表示底层的系统调用，一次读取或者写入多少数据，每次读取或者写入的数据就以一个 <code>buffer</code> 的形式挂在 <code>BufferList</code> 尾部，形成了一长串的 <code>Buffer</code>。</p>
<p>也就是说，<code>highWaterMark</code> 只是规定了一次底层读取的大小(或者说流内部的单个缓冲区 Buffer 的大小)，而不是规定这个流的缓冲区内存区域（BufferList）的大小，一个是单个 Buffer，一个是 BufferList，好好品一下。</p>
<p>实际上来说，我们好像没有单纯的控制流的内存大小的参数，之前我在这里纠结了很久，后来做了一系列实验才明白。</p>
<p>当调用 <code>stream.push(chunk)</code> 时，数据会被缓冲在可读流的内部 BufferList 中。 如果流的消费者没有调用 <code>stream.read()</code>，则数据会保留在内部队列中直到被消费。 <code>stream.push(chunk)</code> 在流的消费者不给力的时候（估计是通过 BufferList 长度、BufferList 内存总量、本次读取的字节数量等经过某种逻辑来确定的）会返回 <code>false</code> ，这个时候就是告诉我们：别再往流里发了，下面读不过来。</p>
<p>一旦我们在外部调用 <code>stream.read()</code>，首先就会消费缓冲区，缓冲区没有数据，就会调用底层调用去读取。具体的读取策略比较复杂，我通过实验有一定的想法，但是感觉帮助不大，就不说了</p>
<h2><a class="anchor" aria-hidden="true" id="readablepipedestination-options"></a><a href="#readablepipedestination-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>readable.pipe(destination[, options])</h2>
<p><code>readable.pipe()</code> 方法绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。</p>
<p>可以理解成 <code>bash</code> 中的管道，数据输出到一个管道，然后另一个进程从管道中读取数据，操作系统会控制速率，保证两边的生产和消费速率保持一致(也就是写满的时候阻塞，读不了的时候阻塞)</p>
<p>例子，将可读流的所有数据通过管道推送到 <code>file.txt</code> 文件：</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
<span class="hljs-keyword">const</span> writable = fs.createWriteStream(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-comment">// readable 的所有数据都推送到 'file.txt'。</span>
readable.pipe(writable);
</code></pre>
<p><code>readable.pipe()</code> 会返回目标流的引用，这样就可以对流进行链式地管道操作：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> r = fs.createReadStream(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-keyword">const</span> z = zlib.createGzip();
<span class="hljs-keyword">const</span> w = fs.createWriteStream(<span class="hljs-string">'file.txt.gz'</span>);
r.pipe(z).pipe(w);
<span class="hljs-comment">// 在 Bash 中，等价于：</span>
<span class="hljs-comment">// $ r | z | w</span>
</code></pre>
<p>实际上就是说，<code>z</code> 对于 <code>r</code> 是一个可写流，<code>z</code> 对于 <code>w</code> 是一个可读流，所以可以这样链式调用</p>
<p>默认情况下，当来源可读流触发 <code>'end'</code>事件时，目标可写流也会调用 <code>stream.end()</code>结束写入。 若要禁用这种默认行为， <code>end</code> 选项应设为 <code>false</code>，这样目标流就会保持打开：</p>
<pre><code class="hljs css language-javascript">reader.pipe(writer, { <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> });
reader.on(<span class="hljs-string">'end'</span>, () =&gt; {
  writer.end(<span class="hljs-string">'结束'</span>);
});
</code></pre>
<p>这种行为的用途就是：一个输出可能需要聚集多个地方的输入。比如像 <code>wc</code> 程序，可能需要读取很多输入，并且输出到同一个输出流去，所以在一个流读取完毕的时候，不能就将输出的流都关闭了</p>
<p>如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。</p>
<p><code>process.stderr</code>和 <code>process.stdout</code> 可写流在 Node.js 进程退出之前永远不会关闭，无论指定的选项如何。</p>
<p><code>pipe</code> 方法是使用流最简单的方式。通常的建议是要么使用 <code>pipe</code> 方法、要么使用事件来读取流，要避免混合使用两者。一般情况下使用 <code>pipe</code> 方法时你就不必再使用事件了。但如果你想以一种更加自定义的方式使用流，就要用到事件了。</p>
<h2><a class="anchor" aria-hidden="true" id="流的类型"></a><a href="#流的类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流的类型</h2>
<p>一共有 4 种流：</p>
<ul>
<li><code>Readable</code>：可读流，例如 <code>fs.createReadStream()</code>，我们可以从流中读取数据</li>
<li><code>Writable</code>：可写流，例如 <code>fs.createWriteStream()</code>，我们可以往其中写入数据</li>
<li><code>Duplex</code>：可读又可以写的流，例如 <code>net.Socket</code></li>
<li><code>Transform</code>：在读写过程中可以修改或转换数据的 <code>Duplex</code> 流，它转换正在写入的数据，并使转换后的数据可从该流中读出。我们称这些为转换流。转换流的一个示例可以是gzip流，它压缩写入其中的输入数据</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="流的两种读取模式"></a><a href="#流的两种读取模式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流的两种读取模式</h2>
<p>流动模式(Flowing)和暂停模式(Paused)：</p>
<ul>
<li>在流动模式中，数据自动从底层系统读取，并通过 <code>EventEmitter</code> 接口的事件尽可能快地被提供给应用程序。</li>
<li>在暂停模式中，必须显式调用 <code>stream.read()</code> 读取数据块。</li>
</ul>
<p>两种模式本质上的区别其实是在于 <strong>推送</strong> 和 <strong>拉取</strong>。</p>
<p>流动模式中，node 的后台线程自动去读取数据，然后当到达 <code>highwatermark</code> 时（也就是缓冲区满了的时候）或者是到达流的末尾的时候，就发送一个 <code>data</code> 事件。这样我们去消费该事件就读取到数据了，这就是流动模式。</p>
<p>可以看出，流动模式中，我们不需要控制数据的读取，只需要不停的消费 <code>data</code> 事件即可，换句话说，我们是无法实现数据读取的控制的。</p>
<p>暂停模式中，node 的后台线程自动去读取数据，然后当到达 <code>highwatermark</code> 时（也就是缓冲区满了的时候）或者到达流的末尾的时候，停止读取。也就是说，后台线程仅仅是自动读取到缓冲区，而不会将其发送出去。</p>
<p>我们使用 <code>stream.read()</code> 去读取数据时，首先去流的 <code>Buffer</code> 中读取，如果 <code>Buffer</code> 读完了，就调用底层的系统调用去读取数据。</p>
<p>这样，我们就可以控制流的读取方式，例如常见的 <strong>TLV协议（type-length-value）</strong>中，我们首先读取 1 个字节的数据，表示数据的类型，再读取 4 个字节的数据，表示数据的内容长度（length），最后再去读取 <code>length</code> 个字节，表示数据的内容。使用暂停模式就可以很容易做到这样的读取控制，而流动模式则无法做到。</p>
<p>或者是有时我们想读到某个数据就结束读取，例如查找流中的某串字符，中途找到了就不再去读取了，使用流动模式的话都会有些麻烦。</p>
<h2><a class="anchor" aria-hidden="true" id="读取模式切换"></a><a href="#读取模式切换" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>读取模式切换</h2>
<p>所有可读流都开始于暂停模式，可以通过以下方式切换到流动模式：</p>
<ul>
<li>添加 <code>'data'</code> 事件句柄，也就是调用了 <code>stream.on('data',processFn(chunk){})</code></li>
<li>调用 <code>stream.resume()</code> 方法。</li>
<li>调用 <code>stream.pipe()</code> 方法将数据发送到可写流。</li>
</ul>
<p>可读流可以通过以下方式切换回暂停模式：</p>
<ul>
<li>如果没有管道目标，也就是没有使用过 <code>stream.pipe(target)</code>，则调用 <code>stream.pause()</code></li>
<li>如果有管道目标，则移除所有管道目标。调用 <code>stream.unpipe()</code> 可以移除多个管道目标。</li>
</ul>
<p>只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。</p>
<p>为了向后兼容，移除 <code>'data'</code> 事件句柄不会自动地暂停流。 如果有管道目标，一旦目标变为 <code>drain</code> 状态并请求接收数据时，则调用 <code>stream.pause()</code> 也不能保证流会保持暂停模式。</p>
<p>如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。例如，当调用 <code>readable.resume()</code> 时，没有监听 <code>'data'</code> 事件或 <code>'data'</code> 事件句柄已移除。</p>
<p>添加 <code>'readable'</code>事件句柄会使流自动停止流动，并通过 <code>readable.read()</code> 消费数据。 如果 <code>'readable'</code> 事件句柄被移除，且存在 <code>'data'</code> 事件句柄，则流会再次开始流动。</p>
<p>流动模式：</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> rs = fs.createReadStream(<span class="hljs-string">'/dev/urandom'</span>)
<span class="hljs-keyword">var</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>
rs.on(<span class="hljs-string">'data'</span>, (data) =&gt; {
    <span class="hljs-built_in">size</span> += data.length
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'File size:'</span>, <span class="hljs-built_in">size</span>)
})
</code></pre>
<p>暂停模式：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> rs = fs.createReadStream(__filename);
<span class="hljs-keyword">var</span> readerCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> stage = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.read(nextReadSize(stage));
        <span class="hljs-keyword">while</span> (data !== <span class="hljs-literal">null</span>) {
            stage++;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'File size:'</span>, data.length);
            data = <span class="hljs-keyword">this</span>.read(nextReadSize(stage));
        }
    }
}
rs.on(<span class="hljs-string">'readable'</span>, readerCall());
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextReadSize</span>(<span class="hljs-params">stage</span>) </span>{
    <span class="hljs-keyword">return</span> ((stage % <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>) * <span class="hljs-number">10</span>;
}
<span class="hljs-comment">// 10 20 30 的循环读取，使用闭包来保存读取状态</span>
</code></pre>
<p>重点在于 3 处：</p>
<ul>
<li>暂停模式触发 <code>readable</code> 事件后，我们必须要一直循环读取数据，一直读到 <code>null</code> 为止，所以这种处理模式中一定有一个类似于 <code>while(data !== null){... data = stream.read()}</code> 的循环结构，保证触发 <code>readable</code> 事件后将数据读取完毕</li>
<li>每次读取数据后，都要考虑下次数据如何进行读取</li>
<li>当到达流数据的尽头时， <code>'readable'</code> 事件也会触发，但是在 <code>'end'</code> 事件之前触发。</li>
<li><code>'readable'</code> 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。 对于前者，<code>stream.read()</code> 会返回可用的数据。 对于后者，<code>stream.read()</code> 会返回 <code>null</code>。</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="流事件"></a><a href="#流事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流事件</h2>
<p>除了从可读流中读取数据写入可写流以外，<code>pipe</code> 方法还自动帮你处理了一些其他情况。例如，错误处理，文件结尾，以及两个流读取/写入速度不一致的情况。</p>
<p>然而，流也可以通过事件来读取，这个就是 node 的异步所在了，在 Java 中，BIO 是阻塞读取，因此固定的模式是 <code>读取-处理-下一次读取</code>。而 node 中的模式是 <code>创建读取流-监听事件-接收到事件通知-处理事件</code>，我们只需要声明自己关注的事件，node 的后台线程自己去使用<strong>非阻塞方法读取</strong>，然后发现我们声明的事件后，就将其转交给我们的主线程去处理。</p>
<p>例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// readable.pipe(writable)</span>
readable.on(<span class="hljs-string">'data'</span>, (chunk) =&gt; {
  writable.write(chunk);
});

readable.on(<span class="hljs-string">'end'</span>, () =&gt; {
  writable.end();
});
</code></pre>
<p>以上监听了 <code>data</code> 事件，也就是读取到数据时，就将其写入到 <code>writable</code> ，然后是 <code>end</code> 事件，就关闭 <code>writable</code></p>
<p>可以看出来，其实 Java 的 NIO 也是这种类似的模式。</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/15/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/node基础/Buffer"><span class="arrow-prev">← </span><span>Buffer</span></a><a class="docs-next button" href="/docs/nodejs/node基础/事件循环机制"><span>事件循环机制</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#什么是流">什么是流</a></li><li><a href="#流和缓冲区">流和缓冲区</a></li><li><a href="#readablepipedestination-options">readable.pipe(destination[, options])</a></li><li><a href="#流的类型">流的类型</a></li><li><a href="#流的两种读取模式">流的两种读取模式</a></li><li><a href="#读取模式切换">读取模式切换</a></li><li><a href="#流事件">流事件</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>