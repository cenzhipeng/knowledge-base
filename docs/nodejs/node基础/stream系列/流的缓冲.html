<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要记录 node 中的流(Stream)的缓冲的相关内容（仅包括普通的流，不涵盖对象流的内容）"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要记录 node 中的流(Stream)的缓冲的相关内容（仅包括普通的流，不涵盖对象流的内容）"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/docusaurus/快速开始/install" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>stream系列</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Docusaurus<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/install">安装运行</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/config">目录结构和配置</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/build">构建并发布到 Github Pages</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/node基础/stream系列/流的缓冲.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要记录 node 中的流(Stream)的缓冲的相关内容（仅包括普通的流，不涵盖对象流的内容）</p>
<h2><a class="anchor" aria-hidden="true" id="可读流缓冲区"></a><a href="#可读流缓冲区" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可读流缓冲区</h2>
<p>node 中的可读流和可写流都有缓冲区，实际上来说就是一个 <code>BufferList</code>，可以分别使用的 <code>writable.writableBuffer</code> 或 <code>readable.readableBuffer</code> 来获取。</p>
<p>这个缓冲区就是一系列的 Buffer 的列表，可读流的 <code>BufferList</code> 中的每个 <code>Buffer</code> 都是我们在调用 <code>readable.push(chunk)</code> 时的那个 <code>chunk</code> 缓冲。对于普通的流来说，<code>highWaterMark</code> 指定了缓冲区字节的总数。 对于对象模式的流， <code>highWaterMark</code> 指定了对象的总数。</p>
<h3><a class="anchor" aria-hidden="true" id="_readsize-方法"></a><a href="#_readsize-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>_read(size) 方法</h3>
<p>这个方法是流的底层读取方法，表示可读流要去数据源获取多少个字节的数据。因为一个可读流必然是能被读取出一系列字节的流，那么这些字节其实也是有一个来源的，可能是从其它地方读取的，可能是自己生成的，总之是有一个来源途径。这个 <code>_read(size)</code> 就表示：可读流从底层来源获取到 <code>size</code> 个字节的数据存储在自己的缓冲区中。实际上我们都是使用 <code>readable.read(size)</code> 去读取可读流的，而我们读取的其实就是可读流的缓冲区，如果缓冲区的内容不够我们读的，那自然需要可读流去底层读取内容填充到缓冲区中去(调用 <code>_read(size)</code>)，可读流的工作方式就是类似于这种生产者消费者模型的方式。</p>
<p>当我们调用 <code>readable.read(size)</code> 的时候，如果缓冲区没有到达 <code>highWaterMark</code> 字节（其实只有第一次读和读到末尾时才会出现这种情况），流就会调用底层的 <code>_read(size0)</code> 方法，这里的 <code>size0</code> 规则：大于等于 size 但最接近 size 的2的n次方、highWaterMark，这两者中的较大的值，<strong>并且将新的 <code>highWaterMark</code> 更新为本次读取的值，也就是确保本次读取不会减少缓冲区的大小，而且 <code>highWaterMark</code> 会动态增大</strong>。</p>
<p>也就是说：</p>
<ul>
<li><code>highWaterMark = 4</code> ，<code>size = 5</code>，那么将会调用 <code>_read(8)</code>，同时 <code>highWaterMark</code> 调整为 8</li>
<li><code>highWaterMark = 4</code> ，<code>size = 2</code>，那么将会调用 <code>_read(4)</code></li>
</ul>
<p><code>_read(size0)</code>读取完毕后，缓冲区大小有可能仍旧小于 <code>highWaterMark</code> 字节，此时会再次调用 <code>_read(size0)</code> 确保缓冲区缓冲了 <code>highWaterMark</code> 字节。</p>
<h3><a class="anchor" aria-hidden="true" id="highwatermark"></a><a href="#highwatermark" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>highWaterMark</h3>
<p>它定义了缓冲区应该保存的字节数量，当缓冲区即将满溢时，我们调用 <code>readable.push(chunk)</code> 将返回 <code>false</code> ，告知我们不应该再读取数据到流的缓冲区去了。例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> { Readable, Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialCharStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Readable</span> </span>{
    <span class="hljs-keyword">constructor</span>(max, options) {
        <span class="hljs-keyword">super</span>(options);
        <span class="hljs-keyword">this</span>.max = max;
        <span class="hljs-keyword">this</span>.num = <span class="hljs-number">0</span>;
    }
    _read(size) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'size is: '</span> + size);
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.max &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.push(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-string">'a'</span>.charCodeAt(<span class="hljs-number">0</span>) + <span class="hljs-keyword">this</span>.num % <span class="hljs-number">26</span>)));
            <span class="hljs-keyword">this</span>.num++;
            <span class="hljs-keyword">this</span>.max--;
            size--;
            <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-keyword">this</span>.push(<span class="hljs-literal">null</span>);
    }
}
<span class="hljs-keyword">const</span> rns = <span class="hljs-keyword">new</span> SerialCharStream(<span class="hljs-number">100</span>, {
    <span class="hljs-attr">highWaterMark</span>: <span class="hljs-number">4</span>
});
<span class="hljs-built_in">console</span>.log(rns.read(<span class="hljs-number">5</span>));

</code></pre>
<p>上述代码定义了一个可读流，它会循环地生成 <code>abcd...abcd</code> 字符。每次底层读取时都会输出读取 <code>readable.push</code> 时的返回值</p>
<p><code>const rns = new SerialCharStream(100, {highWaterMark: 4 });</code> 定义了一个可以读取100个字符的可读流，缓冲区大小定义为 4</p>
<p><code>console.log(rns.read(5));</code> 表示我们要从流中读取 5 个字节。</p>
<p>最后输出如下：</p>
<pre><code class="hljs css language-javascript">size is: <span class="hljs-number">8</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
&lt;Buffer <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span>&gt;
size is: <span class="hljs-number">8</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
<span class="hljs-literal">false</span>
<span class="hljs-literal">false</span>
<span class="hljs-literal">false</span>
</code></pre>
<p><code>size is: 8</code> 表示 <code>highWaterMark</code> 此次调整为 8 了，因为 <code>rns.read(5)</code> 超出了 <code>highWaterMark</code> 的大小，所以 <code>highWaterMark</code> 会自动调大。</p>
<p>第二次 <code>size is: 8</code> 是表示：经过第一次的底层读取 8 个字节后，再被 <code>rns.read(5)</code> 读取走了 5 个字节，此时缓冲区大小未满，那么就会再次调用 <code>_read(highWaterMark)</code> 去缓存数据。而在此次读取途中就会读满缓冲区，因此第二次读取的时候输出了前面 4 个 true，后面 4 个 false。符合标准的流在 <code>_read(size)</code> 方法中，第一次返回 <code>this.push(chunk)</code> 为 false 时就应该停止读取，从方法中返回，以此保证不会超出缓冲区的大小。</p>
<p>从以上可以看出，可读流的缓冲区基本上会保持在 <code>highWaterMark</code> 的大小，除非是第一次读取、以及读取到了流的末尾。</p>
<p>我们在自定义流的时候，如果要实现最标准的流，一定要确保 <code>_read(size)</code> 方法在第一次 <code>this.push(chunk)</code> 为 false 时就返回。</p>
<h3><a class="anchor" aria-hidden="true" id="pushchunk-方法"></a><a href="#pushchunk-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>push(chunk) 方法</h3>
<p>可读流的底层方法，将 Buffer 添加到可读流的缓冲区。可能这么说会让人比较疑惑，为什么可读流要有往里面添加数据的方法，但是再仔细想想就能明白：可读流是需要产生字节内容的，而这个内容本身是怎么来的呢？肯定是从其它的流或者内容中添加进来的，而 <code>push(chunk)</code> 就是可读流的这么一个添加机制。我们往可读流里 <code>push(chunk)</code> 了什么内容，就决定了我们可以从可读流中读取到什么内容。</p>
<p>正常来说，我们只应该在自定义可读流的 <code>_read(size)</code> 方法里使用 <code>push(chunk)</code> 方法，在通常的使用一个现成的流的时候，基本不应该使用这个方法，除非你确实很清楚你在干什么。</p>
<p>当可读流处在暂停模式时，使用 <code>readable.push()</code> 添加的数据可以在触发 <code>'readable'</code> 事件时通过调用 <code>readable.read()</code>读取。</p>
<p>当可读流处于流动模式时，使用 <code>readable.push()</code> 添加的数据可以通过触发 <code>'data'</code> 事件读取。但是这种情况下，流的读取可能不是按照顺序来的了，因为我们是先触发了 <code>data</code> 事件，后 <code>push</code> ，那么后面 <code>push</code> 触发的 <code>data</code> 事件我们无法控制顺序。</p>
<ul>
<li><p><code>push(chunk)</code> 会往可读流的 <code>BufferList</code> 添加这个 <code>chunk</code>，也就是相当于可读流读取到了底层的数据到缓冲区。会触发 <code>data</code> 事件或者 <code>readable</code> 事件</p></li>
<li><p><code>push(chunk)</code> 返回 false 的时候表示缓冲区已经满了，这时候在我们自定义可读流的 <code>_read(size)</code> 方法中，就应该立刻返回</p></li>
<li><p><code>push(null)</code> 表示我们要结束这个可读流了，会触发 <code>end</code> 事件。所以我们自定义流里面可以在需要结束流时进行 <code>push(null)</code> 调用。</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="可写流缓冲区"></a><a href="#可写流缓冲区" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可写流缓冲区</h2>
<p>和可读流的缓冲区一样，可写流的内部也有一个缓冲区 <code>WritableBuffer</code>，它是一个 <code>BufferList</code> 的结构，存储了一系列的 <code>Buffer</code> 对象。每个 <code>Buffer</code> 对象其实就是咱们在调用 <code>writable.write(chunk)</code> 时的 <code>chunk</code>。</p>
<p>可写流的作用就是：我们调用 <code>write</code> 之类的方法，往可写流中写数据，而可写流最终将数据输出到了某个地方，例如标准输出流、文件等。</p>
<p>可写流的缓冲区的作用就是：平衡我们往可写流的写入速度和可写流往目的地的输出速度。例如可写流向文件输出时，速度会比较慢，因为需要经过底层的系统调用，而且磁盘IO本就很慢，通常来说比咱们内存速度低一两个数量级。有缓冲区之后，我们就往缓冲区写入数据，可写流从缓冲区中拿走数据进行底层的系统调用进行输出。这样有以下好处：</p>
<ul>
<li>减少了系统调用的次数，因为每次会拿走一整块的缓冲内容，单次写入多，那么写入的次数肯定少。这样的话性能自然会有提升（底层系统调用相当耗费资源和性能）</li>
<li>如果底层写入慢，因为有了缓冲区，我们在缓冲区满了的时候，就知道不再往可写流里写入数据了，那么就可以去处理进程的其它任务，这样就不需要浪费CPU资源</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="_writechunk-encoding-callback-方法"></a><a href="#_writechunk-encoding-callback-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>_write(chunk, encoding, callback) 方法</h3>
<ul>
<li><code>chunk</code>：要写入的 <code>Buffer</code>，从传给 <code>stream.write()</code> 的 <code>string</code> 转换而来。 如果流的 <code>decodeStrings</code> 选项为 <code>false</code> 或者流在对象模式下运行，则数据块将不会被转换，并且将是传给 <code>stream.write()</code> 的任何内容。</li>
<li><code>encoding</code>：如果 <code>chunk</code> 是字符串，则指定字符编码。 如果 <code>chunk</code> 是 <code>Buffer</code> 或者流处于对象模式，则无视该选项。</li>
<li><code>callback</code>：当数据块被处理完成后的回调函数。这个回调通知可写流：这次的底层输出的调用已经完成了，可以接着下一次的输出了。当出现错误时，也可以传递一个 error 参数。</li>
</ul>
<p>这个方法是底层输出调用，只应该在可写流内部使用。当缓冲区有数据时，就会调用这个方法去输出到底层输出。当 <code>callback</code> 回调被调用之后，输出流就知道本次的底层输出完成了，如果缓冲区有数据，就会进行下一次的 <code>_write()</code> 调用去输出缓冲区里的数据，如果缓冲区里没有数据了，就会发送 <code>drain</code> 事件，表示底层输出完毕了，可以接着往缓冲区写数据了。</p>
<blockquote>
<p>注意：一定要调用了 <code>callback</code> 才能通知流：本次输出完毕了。如果没有调用 <code>callback</code>，流就会认为还在输出中（有的输出相当耗时，例如网络IO），从而不会调用下一次输出</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="writablewritechunk-encoding--callback"></a><a href="#writablewritechunk-encoding--callback" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>writable.write(chunk[, encoding] [, callback])</h3>
<ul>
<li><code>chunk</code>：要写入的数据。  对于非对象模式的流， <code>chunk</code> 必须是字符串、 <code>Buffer</code> 或 <code>Uint8Array</code>。 对于对象模式的流， <code>chunk</code> 可以是任何 JavaScript 值，除了 <code>null</code>。</li>
<li><code>encoding</code>：如果 <code>chunk</code> 是字符串，则指定字符编码。</li>
<li><code>callback</code>：当数据块被输出到目标后的回调函数。</li>
<li>返回：如果流需要等待 <code>drain</code> 事件触发才能继续写入更多数据，则返回 <code>false</code>，否则返回 <code>true</code>。其实就是说，返回 <code>false</code> 时，我们需要停止继续往输出流中写数据了，此时缓冲的数据还未写完，继续写缓冲区将会溢出。实际上继续写也是可以，最终来看就是内存占用越来越高，直到最后内存实在撑不住了就炸裂了。如果内存足够的话，可能数据最终还是会写完而且内存不会溢出，从内存占用来看就是内存一开始越来越高（因为输出流中积压了太多数据而写入的底层调用过慢），后来内存慢慢开始降低（可能往输出流写入的数据此时已经全部在输出流的缓冲区了，也就是缓冲区不会再变大了，内存就会开始降低，因为底层还在一直写出），直到最后完成</li>
</ul>
<p><code>writable.write()</code> 写入数据到流，并在数据被完全处理之后调用 <code>callback</code>。 如果发生错误，则 <code>callback</code> 可能被调用也可能不被调用。 为了可靠地检测错误，可以为 <code>'error'</code> 事件添加监听器。</p>
<p>在接收了 <code>chunk</code> 后，如果内部的缓冲小于创建流时配置的 <code>highWaterMark</code>，则返回 <code>true</code> 。 如果返回 <code>false</code> ，则应该停止向流写入数据，直到 <code>'drain'</code> 事件被触发。也就是说：一旦 <code>write</code> 返回了 <code>false</code>，我们就应该停止写入，直到触发了 <code>'drain'</code> 事件。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> { Readable, Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
    _write(chunk, enc, done) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'_write is called: '</span> + chunk.toString().toUpperCase() + <span class="hljs-string">' | time is: '</span> + process.uptime());
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            done();
        }, <span class="hljs-number">10000</span>); <span class="hljs-comment">// 表示我们输出一次需要10秒钟</span>
    }
}
<span class="hljs-keyword">var</span> out = <span class="hljs-keyword">new</span> OutputStream({ <span class="hljs-attr">highWaterMark</span>: <span class="hljs-number">8</span> });
<span class="hljs-built_in">console</span>.log(out.write(<span class="hljs-string">'1111'</span>));
<span class="hljs-built_in">console</span>.log(out.writableBuffer);
<span class="hljs-built_in">console</span>.log(out.write(<span class="hljs-string">'222'</span>));
<span class="hljs-built_in">console</span>.log(out.write(<span class="hljs-string">'3333'</span>));
<span class="hljs-built_in">console</span>.log(out.writableBuffer);
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs css language-bash">_write is called: 1111 | time is: 0.138032964
<span class="hljs-literal">true</span>
[]
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
[
  {
    chunk: &lt;Buffer 32 32 32&gt;,
    encoding: <span class="hljs-string">'buffer'</span>,
    isBuf: <span class="hljs-literal">true</span>,
    callback: [Function: nop],
    next: {
      chunk: &lt;Buffer 33 33 33 33&gt;,
      encoding: <span class="hljs-string">'buffer'</span>,
      isBuf: <span class="hljs-literal">true</span>,
      callback: [Function: nop],
      next: null
    }
  },
  {
    chunk: &lt;Buffer 33 33 33 33&gt;,
    encoding: <span class="hljs-string">'buffer'</span>,
    isBuf: <span class="hljs-literal">true</span>,
    callback: [Function: nop],
    next: null
  }
]
_write is called: 222 | time is: 10.15297613
_write is called: 3333 | time is: 20.158242229
</code></pre>
<p>可以看到，第一次调用 <code>write</code>，立刻就会进行底层的输出，然后后续调用都加入到了缓冲区，直到 10 秒后，第一次底层输出完毕了，才会继续输出缓冲区的数据</p>
<h3><a class="anchor" aria-hidden="true" id="highwatermark-1"></a><a href="#highwatermark-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>highWaterMark</h3>
<p>定义了可写流的缓冲区字节数。当我们 <code>write(chunk)</code> 时缓冲区即将大于 <code>highWaterMark</code> 时，就将会返回 <code>false</code> 以此机制来控制写入速度。<code>pipe()</code> 方法之所以能协调两个流的速度，也是靠了这种背压机制。</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/15/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/node基础/示例代码"><span class="arrow-prev">← </span><span>示例代码</span></a><a class="docs-next button" href="/docs/nodejs/node基础/stream系列/可读流"><span>可读流</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#可读流缓冲区">可读流缓冲区</a><ul class="toc-headings"><li><a href="#_readsize-方法">_read(size) 方法</a></li><li><a href="#highwatermark">highWaterMark</a></li><li><a href="#pushchunk-方法">push(chunk) 方法</a></li></ul></li><li><a href="#可写流缓冲区">可写流缓冲区</a><ul class="toc-headings"><li><a href="#_writechunk-encoding-callback-方法">_write(chunk, encoding, callback) 方法</a></li><li><a href="#writablewritechunk-encoding--callback">writable.write(chunk[, encoding] [, callback])</a></li><li><a href="#highwatermark-1">highWaterMark</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>