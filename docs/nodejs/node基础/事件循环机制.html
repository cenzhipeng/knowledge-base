<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要记录一些 node 中关于事件循环机制的内容"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要记录一些 node 中关于事件循环机制的内容"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Node 基础</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JVM系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/JVM系列/JVM内存区域">JVM内存区域</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/对象创建-布局-访问">对象创建-布局-访问</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存溢出实战">内存溢出实战</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存区域回收">内存区域回收</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/四大引用">四大引用</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/垃圾回收算法">垃圾回收算法</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/HotSpot回收算法细节">HotSpot回收算法细节</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/块级作用域">块级作用域</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/字符串和正则表达式">字符串和正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/对象">对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Symbol">Symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Set和Map">Set和Map</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/迭代器和生成器">迭代器和生成器</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/类">类</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/数组">数组</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Promise">Promise</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/node基础/事件循环机制.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要记录一些 node 中关于事件循环机制的内容</p>
<p>参考：</p>
<ul>
<li><a href="http://www.ayqy.net/blog/javascript-macrotask-vs-microtask/">http://www.ayqy.net/blog/javascript-macrotask-vs-microtask/</a></li>
<li><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="事件循环"></a><a href="#事件循环" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事件循环</h2>
<ul>
<li>node 进程启动后，就开启了一个事件循环（单个线程）</li>
<li>事件循环包含有 6 个阶段：
<ul>
<li>poll</li>
<li>check</li>
<li>close callbacks    <strong>结束阶段的回调，不是重点</strong></li>
<li>timers</li>
<li>pending callbacks    <strong>node 内部使用的阶段</strong></li>
<li>idle，prepare    <strong>node 内部使用的阶段</strong></li>
</ul></li>
<li>每个阶段都是一个类似于 FIFO 的队列，队列中都是回调函数，当进入一个阶段时，会依次执行该阶段的回调函数，直到满足一定条件离开该阶段，跳转到其它阶段</li>
<li>事件循环执行过程就是根据一定规则不停的在以上这些阶段中跳转，当所有阶段的所有回调都执行完毕了，并且不需要再等待异步 IO 事件时，则退出事件循环，最终表现为：进程退出</li>
</ul>
<p><img src="../../assets/1*QozygAtocqBGy2YEjM4yag.png" alt="img"></p>
<h2><a class="anchor" aria-hidden="true" id="进程启动"></a><a href="#进程启动" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进程启动</h2>
<p>node 进程启动后，就会开始执行用户代码，同步执行完了用户代码后，就开始执行事件循环。</p>
<p>也就是说，当我们执行 <code>node hello.js</code> 时，<code>hello.js</code> 内容如下：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>);
</code></pre>
<p>此时 node 的单线程的状态如下（伪代码）：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>);
event_loop(timers_phase)
</code></pre>
<p>也就是说，<strong>进程启动后，先执行我们自己写的代码，然后立刻进入事件循环，运行在 timers 阶段</strong></p>
<p>这些所有的运行过程，都是在单个线程中的</p>
<h2><a class="anchor" aria-hidden="true" id="重点阶段"></a><a href="#重点阶段" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重点阶段</h2>
<p>我们真正打交道较多的阶段，就是下面 3 个阶段，分别是 timers、poll、check</p>
<h2><a class="anchor" aria-hidden="true" id="timers-阶段"></a><a href="#timers-阶段" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>timers 阶段</h2>
<p>本阶段执行被 <code>setTimeout()</code> 和 <code>setInterval()</code> 调度的回调函数。</p>
<p>执行的是那些超过了时间阈值的回调。例如，我们在进程启动后 500 毫秒时，进入了 timers 阶段，timers 队列中有 3 个定时器，设置的时间分别是 400 毫秒、500 毫秒、1000 毫秒。那么将会执行前两个定时器，执行完毕后，假设进程启动时间到了 700 毫秒，此时小于 1000 毫秒，第三个定时器就不会执行。</p>
<p>此时，本轮的 timers 阶段就结束了，于是事件循环就跳转到 poll 阶段。</p>
<blockquote>
<p>注：定时器无法保证精确的执行时间，因为会受到操作系统的进程调度的影响，以及线程执行时可能阻塞在了其它的回调事件中，到了去处理定时器时，可能已经超过定时器的时间很久了</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="poll-阶段"></a><a href="#poll-阶段" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>poll 阶段</h2>
<p>在 node.js 里，任何异步方法（除 timer，close，setImmediate 之外）<strong>完成时</strong>，都会将其回调加到 poll 队列里，然后执行。</p>
<p>如果事件循环进入了 poll 阶段，将会发生下面情况：</p>
<ul>
<li><p>如果 poll 队列不为空，事件循环将同步的执行这个 poll 队列里的回调，直至为空，或执行的回调数量到达系统上限</p></li>
<li><p>如果 poll 队列为空，将会发生下面情况：</p>
<ul>
<li><p>如果代码已经被 setImmediate() 设定了回调（check 队列中有回调），事件循环将结束 poll 阶段进入 check 阶段，并执行 check阶段的回调队列（也就是说 check 队列里只有 setImmediate() 的回调）</p></li>
<li><p>如果代码没有设定 setImmediate() 回调（check 队列中没有回调），将会有以下情况：</p>
<ul>
<li><p>timers 队列有到达了时间阈值的定时器（也就是已经可以触发的定时器）：跳转进入 timers 阶段</p></li>
<li><p>timers 队列没有可触发的定时器：事件循环阻塞在 poll 阶段，轮询 IO 事件，等待事件完成，然后将回调加入 poll 队列，然后立即执行该回调队列。（一次轮询可能返回多个事件）</p>
<ul>
<li>这里有个小细节：poll 阶段的阻塞是有个超时时间的，那就是最早的 timer 定时器的到达时间</li>
<li>也就是说：poll 阶段发现当前没有定时器可以触发，但是 2 秒后会有一个定时器到达时间了，那么 poll 阶段就会阻塞 2 秒，确保 2 秒后要么有新事件发生了可以执行回调，要么跳转到定时器队列去执行触发了的定时器</li>
</ul>
<blockquote>
<p><strong>poll 阶段阻塞的这种情况下，就是在等待异步方法完成，例如 <code>fs.readFile(path[, options], callback)</code>，当这个异步方法完成的时候（读完了数据后），将会由内核通知 node 进程，然后 node 进程就会将回调加入到 poll 队列，poll 阶段立即执行该回调。</strong></p>
</blockquote></li>
</ul></li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="check-阶段"></a><a href="#check-阶段" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>check 阶段</h2>
<p>check 阶段执行使用 setImmediate() 方法设置的回调。当我们使用 <code>setImmediate(callback)</code> 时，回调会被加入到 check 队列。</p>
<p>进入到 check 队列后，将会执行所有 check 队列的回调，然后进入 close callbacks 阶段（不是重点），接着进入 timers 阶段。</p>
<h2><a class="anchor" aria-hidden="true" id="测试代码示例"></a><a href="#测试代码示例" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试代码示例</h2>
<h3><a class="anchor" aria-hidden="true" id="例子1"></a><a href="#例子1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子1</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> start = process.uptime();
fs.readFile(__filename, () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'poll:'</span> + process.uptime());
});
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timer:'</span> + process.uptime());
},<span class="hljs-number">3</span>); 
<span class="hljs-comment">// 阻塞 5 毫秒</span>
<span class="hljs-keyword">while</span>( process.uptime() - start &lt; <span class="hljs-number">0.005</span>){
    ;
}
setImmediate(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'check:'</span> + process.uptime());
});
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">timer:<span class="hljs-number">0.049632078</span>  
<span class="hljs-attr">check</span>:<span class="hljs-number">0.057028269</span>
<span class="hljs-attr">poll</span>:<span class="hljs-number">0.057422407</span>
</code></pre>
<p>分析：</p>
<ol>
<li>首先执行用户代码，添加定时器在 3 毫秒后，然后阻塞 5 毫秒，确保定时器达到触发条件了</li>
<li>使用 setImmediate() ，添加到 check 队列回调</li>
<li>这串代码执行完毕后，开始进入事件循环，此时 poll 暂时为空（IO 回调需要在 poll 阶段进行阻塞轮询才会被添加到 poll 队列）</li>
<li>事件循环首先进入 timers 阶段，发现时间已经到了 5 毫秒，3 毫秒的<strong>定时器就触发了</strong>，回调执行完后 timers 队列为空</li>
<li>timers 阶段结束，进入 poll 阶段</li>
<li>poll 阶段发现 poll 队列为空，并且 check 队列不为空，于是 poll 阶段结束，进入 check 阶段</li>
<li><strong>check 阶段执行所有回调</strong></li>
<li>check 队列为空，check 阶段结束，进入 poll 阶段</li>
<li>poll 阶段发现 poll 队列为空、check 队列为空、timers 为空，并且还有没去轮询的事件</li>
<li>poll 阶段进入无限时长的阻塞，直到 readFile 完成</li>
<li><strong>将 readFile 的回调进行调用</strong></li>
</ol>
<blockquote>
<p>注：回调发生在上述分析过程的 4、7、11 步骤</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="例子2"></a><a href="#例子2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子2</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> start = process.uptime();
fs.readFile(__filename, () =&gt; {
    <span class="hljs-comment">// console.log('poll:' + process.uptime());</span>
    fs.readFile(__filename, () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'poll:'</span> + process.uptime());
    });
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timer:'</span> + process.uptime());
    },<span class="hljs-number">3</span>); 
    <span class="hljs-comment">// 阻塞 500 毫秒</span>
    <span class="hljs-keyword">while</span>( process.uptime() - start &lt; <span class="hljs-number">0.5</span>){
        ;
    }
    setImmediate(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'check:'</span> + process.uptime());
    });
});
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">check:<span class="hljs-number">0.548693043</span>
<span class="hljs-attr">timer</span>:<span class="hljs-number">0.556296747</span>
<span class="hljs-attr">poll</span>:<span class="hljs-number">0.55664583</span>
</code></pre>
<p>分析：</p>
<ol>
<li>首先执行用户代码，添加了一个读取文件的异步事件</li>
<li>poll、check、timers 队列都是空的，因此无限时长阻塞在 poll 阶段等待读取事件完成</li>
<li>读取事件完成后，执行回调方法</li>
<li>回调方法中，再次进行异步读取操作，然后添加一个 3 毫秒后的定时器，阻塞 500 毫秒确保定时器决定达到了触发条件</li>
<li>添加一个回调到 check 队列</li>
<li>回调执行完毕，poll 队列为空，此时 check 队列不为空</li>
<li>因此 poll 阶段结束，跳转进入 check 阶段，<strong>执行 check 回调</strong></li>
<li>check 阶段结束，进入 timers 阶段</li>
<li>定时器触发，<strong>执行 timers 的回调</strong></li>
<li>timers 队列为空，结束 timers 阶段，进入 poll 阶段</li>
<li>poll 队列为空，并且发现 check 和 timers 都为空，那么进入无限期阻塞等待读取事件完成</li>
<li>读取事件完成，<strong>执行 poll 阶段的回调</strong>，此时所有队列为空，并且没有需要等待的事件了，此时进程退出</li>
</ol>
<blockquote>
<p>注：回调发生在上述分析过程的 7、9、12 步骤</p>
<p>另外从分析中可以看出，无论我们在第一次的读取事件回调里阻塞多久，都会是 setImmediate 的回调先于定时器的回调执行。</p>
<p>在例子 1 中，定时器和 setImmediate 的执行顺序，则取决于主线程的执行时间，如果执行主线程代码结束时，定时器达到触发条件，则会先于 setImmediate 执行，否则定时器将会后执行。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="例子3"></a><a href="#例子3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子3</h3>
<p>首先，创建一个超大的文件</p>
<pre><code class="hljs css language-bash">$ node -e <span class="hljs-string">'console.log(Buffer.alloc(1024 * 1024 * 1000).toString())'</span> &gt; tmp.data
</code></pre>
<p>然后，代码如下：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> start = process.uptime();
fs.readFile(<span class="hljs-string">'tmp.data'</span>, () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'poll:'</span> + process.uptime());
});
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timer:'</span> + process.uptime());
},<span class="hljs-number">300</span>);
setImmediate(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'check:'</span> + process.uptime());
});
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">check:<span class="hljs-number">0.121103182</span>
<span class="hljs-attr">timer</span>:<span class="hljs-number">0.420729763</span>
<span class="hljs-attr">poll</span>:<span class="hljs-number">1.148161409</span>
</code></pre>
<p>分析：</p>
<ol>
<li>主线程代码执行完，进入 timers 阶段，发现定时器事件没到</li>
<li>转而进入 poll 阶段，poll 队列为空，check 队列不为空，转而进入 check 阶段</li>
<li><strong>于是 check 回调执行</strong>，进入 timers 阶段</li>
<li>timers 定时器事件依然没到，进入 poll 阶段阻塞直到 300 毫秒（最早的定时器触发事件）</li>
<li>由于 readFile 需要接近 1 秒的时间（因为是个 1G 的大文件，所以读取很慢），于是在 300 毫秒时，poll 阶段没有等待到事件返回，从阻塞状态中回来后，跳转到 timers 阶段</li>
<li><strong>执行 timers 的回调</strong>，进入 poll 阶段，此时进入 poll 的无限期阻塞状态</li>
<li>1 秒钟左右时，readFile 事件返回，<strong>执行 poll 回调</strong>，然后 node 进程结束退出</li>
</ol>
<blockquote>
<p>注：回调发生在上述 3、6、7 步骤</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="例子4"></a><a href="#例子4" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子4</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> start = process.uptime();
fs.readFile(__filename, () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'poll:'</span> + process.uptime());
});
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timer:'</span> + process.uptime());
},<span class="hljs-number">300</span>);
setImmediate(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'check:'</span> + process.uptime());
});
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">check:<span class="hljs-number">0.048520728</span>
<span class="hljs-attr">poll</span>:<span class="hljs-number">0.058550448</span>
<span class="hljs-attr">timer</span>:<span class="hljs-number">0.351791715</span>
</code></pre>
<p>分析：</p>
<ol>
<li>这个例子与 例子3 的唯一区别是，读取的是 <code>__filename</code> 文件，也就是一个不到 1k 的小文件，readFile 调用很快就能返回事件</li>
<li>主线程代码执行完，进入 timers 阶段，发现定时器事件没到</li>
<li>转而进入 poll 阶段，poll 队列为空，check 队列不为空，转而进入 check 阶段</li>
<li><strong>于是 check 回调执行</strong>，进入 timers 阶段</li>
<li>timers 定时器事件依然没到，进入 poll 阶段阻塞直到 300 毫秒（最早的定时器触发事件）</li>
<li>由于 readFile 需要的时间少于 100 毫秒（因为是个小文件，所以读取很快），于是在阻塞 100 毫秒左右时，poll 阶段等待到事件返回，从阻塞状态中回来，将回调加入到 poll 队列，并且<strong>立即执行 poll 阶段的回调</strong></li>
<li>执行完回调后 poll 队列为空，因此继续阻塞直到 300 毫秒左右的 timers 触发</li>
<li><strong>执行 timers 回调</strong>，node 进程结束退出</li>
</ol>
<blockquote>
<p>注：回调发生在上述 4、6、8 步骤</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="microtask-和-macrotask"></a><a href="#microtask-和-macrotask" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>microtask 和 macrotask</h2>
<p>node 中事件循环除了前面的循环阶段外，其实每个阶段还有微任务。微任务是在每个循环阶段结束之后运行的，示例图如下：</p>
<p><img src="../../assets/image-20191218174357853.png" alt="image-20191218174357853"></p>
<p>microtask：</p>
<ul>
<li>process.nextTick</li>
<li>Promise callback</li>
<li>Object.observe    废弃的 API</li>
<li>MutationObserver    用来监听 DOM 事件的一个 API，也是个基本不用的</li>
</ul>
<p>macrotask：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
</ul>
<p>宏任务就是我们之前说的，事件循环的那几个队列里的任务。</p>
<p>例子：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
fs.readFile(__filename, () =&gt; {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timer will be last: '</span> + process.uptime());
    }, <span class="hljs-number">0</span>);
    setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'check: '</span> + process.uptime());
        process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'nextTock after check: '</span> + process.uptime());
            process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'nextTock after check: '</span> + process.uptime());
            });
        });

    });
    process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'nextTock before check: '</span> + process.uptime());
        process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'nextTock before check: '</span> + process.uptime());
        });
    });

})
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">nextTock before check: <span class="hljs-number">0.04490284</span>
nextTock before check: <span class="hljs-number">0.051345693</span>
<span class="hljs-attr">check</span>: <span class="hljs-number">0.051831962</span>
nextTock after check: <span class="hljs-number">0.051936257</span>
nextTock after check: <span class="hljs-number">0.052029718</span>
timer will be last: <span class="hljs-number">0.052334473</span>
</code></pre>
<p>结合上面的图和之前说的关于事件循环的阶段分析，应该很容易明白为什么是这种秩序顺序吧</p>
<ul>
<li>首先进入执行 poll 队列，里面添加了本示例所有的回调</li>
<li>然后 poll 队列为空，发现 check 队列有回调，转而跳转到 check 队列</li>
<li>跳转阶段之前，先执行完所有的 microtask，于是那 2 个微任务在 check 之前执行</li>
<li>执行完 check，跳转到 timers 阶段</li>
<li>跳转阶段之前，先执行完所有的 microtask，于是那 2 个微任务在 check 之后执行</li>
<li>最后执行 timers 阶段</li>
</ul>
<blockquote>
<p>在执行微任务时，微任务本身又添加了微任务，那么本次微任务队列会增加，所以会继续执行完本次添加的微任务，直到本次的微任务队列为空</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="微任务的优先级"></a><a href="#微任务的优先级" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微任务的优先级</h3>
<p>另外就是，微任务其实也分几个队列，起码 nextTick 和 Promise 这两个是处于 2 个不同的微任务队列的，nextTick 的优先级最高。因此，永远都是先执行 nextTick 然后执行 Promise</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/21/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/node基础/Stream"><span class="arrow-prev">← </span><span>Stream</span></a><a class="docs-next button" href="/docs/nodejs/node基础/示例代码"><span>示例代码</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#事件循环">事件循环</a></li><li><a href="#进程启动">进程启动</a></li><li><a href="#重点阶段">重点阶段</a></li><li><a href="#timers-阶段">timers 阶段</a></li><li><a href="#poll-阶段">poll 阶段</a></li><li><a href="#check-阶段">check 阶段</a></li><li><a href="#测试代码示例">测试代码示例</a><ul class="toc-headings"><li><a href="#例子1">例子1</a></li><li><a href="#例子2">例子2</a></li><li><a href="#例子3">例子3</a></li><li><a href="#例子4">例子4</a></li></ul></li><li><a href="#microtask-和-macrotask">microtask 和 macrotask</a><ul class="toc-headings"><li><a href="#微任务的优先级">微任务的优先级</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>