<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文记录 JavaScript 中一些数据处理的 API"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文记录 JavaScript 中一些数据处理的 API"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>JS 基础</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JVM系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/JVM系列/JVM内存区域">JVM内存区域</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/对象创建-布局-访问">对象创建-布局-访问</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存溢出实战">内存溢出实战</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存区域回收">内存区域回收</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/四大引用">四大引用</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/垃圾回收算法">垃圾回收算法</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/块级作用域">块级作用域</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/字符串和正则表达式">字符串和正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/对象">对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Symbol">Symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Set和Map">Set和Map</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/迭代器和生成器">迭代器和生成器</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/类">类</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/数组">数组</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Promise">Promise</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/数据处理.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文记录 JavaScript 中一些数据处理的 API</p>
<h2><a class="anchor" aria-hidden="true" id="数组"></a><a href="#数组" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组</h2>
<ul>
<li><p>数组可以通过字面量与 new 表达式两种方法生成。我们可以将任意的值或者对象的引用指定为元素，并且不需要确保数组中元素类型的一致性。</p></li>
<li><p>在书写数组字面量时，还可以省略一些中间的元素。被省略元素的值将被认为是 undefined 值。例如</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>,,<span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]);
<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">1</span>]);
<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">2</span>]);
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs css language-javascript">(py3<span class="hljs-number">.5</span>) czp@:~<span class="hljs-regexp">/workspace/</span>knowledge-base/demos/node_start$ node hello.js
<span class="hljs-number">3</span>
<span class="hljs-literal">undefined</span>
<span class="hljs-number">5</span>
</code></pre></li>
<li><p>ES 标准中，我们可以在数组最后面加上逗号，那个逗号会被忽略。但是在老版本的 js 和 JSON 的数组中，这个会出现问题。（所以能不加还是别加了）</p></li>
<li><p>如果在赋值表达式左侧所写的下标超过了元素数量，则会向数组增加新的元素。新增的元素下标值 不必紧接着现有元素的个数。这时，如果访问中间被跳过的元素，则会返回 undefined 值。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];
arr[<span class="hljs-number">10</span>] = <span class="hljs-number">7</span>;
<span class="hljs-built_in">console</span>.log(arr.length);
<span class="hljs-built_in">console</span>.log(arr);
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs css language-javascript">(py3<span class="hljs-number">.5</span>) czp@:~<span class="hljs-regexp">/workspace/</span>knowledge-base/demos/node_start$ node hello.js
<span class="hljs-number">11</span>
[ <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, &lt;<span class="hljs-number">7</span> empty items&gt;, <span class="hljs-number">7</span> ]
</code></pre></li>
<li><p>可以显式地更改 length 的值，在进行改写之后数组的长度也会相应发生改变。如果该值变小，超出部分的元素将被舍去。如果该值变大，新增部分的元素将是 undefined 值</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="数组-api"></a><a href="#数组-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组 API</h3>
<p>Array 类的属性</p>
<table>
<thead>
<tr><th>属性名</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>prototype</td><td>用于原型链</td></tr>
<tr><td>length</td><td>值为 1</td></tr>
<tr><td>isArray(arg)</td><td>如果参数 arg 是一个数组实例则返回真</td></tr>
</tbody>
</table>
<p>Array.prototype 对象的属性</p>
<table>
<thead>
<tr><th>属性名</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>constructor</td><td>对 Array 类对象的一个引用</td></tr>
<tr><td>concat([item0, item1,  …  ])</td><td>把参数作为元素加入某一数组并生成新的数组。如果参数本身就是一个数组，则 将这两个数组连接</td></tr>
<tr><td>every(callbackfn[, thisArg])</td><td>依次对数组中的各个元素应用 callbackfn 函数。在 callbackfn 返回 false 之后终止</td></tr>
<tr><td>filter(callbackfn[, thisArg])</td><td>依次对数组中的各个元素应用 callbackfn 函数，并返回函数的返回值为 true 的元 素所组成的新的数组</td></tr>
<tr><td>forEach(callbackfn[, thisArg])</td><td>依次对数组中的各个元素应用 callbackfn 函数</td></tr>
<tr><td>indexOf(searchElement, [fromIndex])</td><td>返回第一个与 searchElement 一致的元素的下标。也可以通过第 2 参数来设置检 索的起始下标。如果没有找到相符的结果，则返回 -1</td></tr>
<tr><td>join(separator)</td><td>在数组的元素之间加入分隔符之后生成相应的字符串值</td></tr>
<tr><td>lastIndexOf(searchElement[, fromIndex])</td><td>从后向前检索，返回第一个与 searchElement 一致的元素的下标。也可以通过第 2 参数来设置检索的起始下标。如果没有找到相符的结果，则返回 -1</td></tr>
<tr><td>map(callbackfn[, thisArg])</td><td>依次对数组中的各个元素应用 callbackfn 函数，返回元素为函数结果的新的数组</td></tr>
<tr><td>pop()</td><td>删除数组中最后一个元素后返回该数组</td></tr>
<tr><td>push([item0, item1, …])</td><td>将参数添加至数组的末尾</td></tr>
<tr><td>reduce(callbackfn[, initialValue])</td><td>将数组的各个元素与之前的函数调用结果作为参数，依次应用 callbackfn 函数， 并返回函数调用的最终结果</td></tr>
<tr><td>reduceRight(callbackfn[, initialValue])</td><td>从数组的末尾开始向前执行 reduce 操作</td></tr>
<tr><td>reverse()</td><td>将数组中的元素逆序置换</td></tr>
<tr><td>shift()</td><td>删除数组中的第一个元素后返回该数组</td></tr>
<tr><td>slice(start, end)</td><td>生成一个下标由 start 起至 end 的元素所组成的新的数组</td></tr>
<tr><td>some(callbackfn[, thisArg])</td><td>依次对数组中的各个元素应用 callbackfn 函数。如果 callbackfn 的结果为 true，则 终止</td></tr>
<tr><td>sort(comparefn)</td><td>将数组中的元素排序</td></tr>
<tr><td>splice(start, delCount, [item0, item1, …])</td><td>删除下标由 start 开始的 delCount 个元素。如果指定了第 3 个参数，则将该参数 插入至前述位置</td></tr>
<tr><td>toLocaleString()</td><td>将数列转换为与地区相关的字符串值类型</td></tr>
<tr><td>toSource()</td><td>JavaScript 自定义的增强功能。求值结果将返回用于函数进行生成的字符串。</td></tr>
<tr><td>toString()</td><td>将数组转换为字符串值类型</td></tr>
<tr><td>unshift([item0, item1, …])</td><td>将元素添加至数组的头部</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="json"></a><a href="#json" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JSON</h2>
<p>JSON 能够通过 4 种基本数据类型以及 2 种结构化数据类型来表示。</p>
<p>4 种基本数据类型是指字符串值型、数值型、布尔型以及 null 型。结构化数据类型是指对象与数组这两种。</p>
<blockquote>
<p>注意：JSON 标准中，对象的属性名必须具有双引号</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="json-的标准"></a><a href="#json-的标准" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JSON 的标准</h3>
<table>
<thead>
<tr><th>数据类型  书写示例  注意点</th><th></th><th></th></tr>
</thead>
<tbody>
<tr><td>字符串值</td><td>&quot;foobar&quot;</td><td>不能使用单引号。字符串的默认编码为 UTF-8</td></tr>
<tr><td>数值</td><td>123.4</td><td>只支持 10 进制书写方式</td></tr>
<tr><td>布尔值</td><td>true 或是 false</td><td></td></tr>
<tr><td>null 值</td><td>null</td><td></td></tr>
<tr><td>对象</td><td>{ &quot;x&quot;:1, &quot;v&quot;:&quot;foo&quot; }</td><td>属性名只能使用字符串的方式表示而不能使用 {x:1} 这样的字面量形式</td></tr>
<tr><td>数组</td><td>{ 1, 2, &quot;foo&quot; }</td><td>数组中的元素可以被指定为任意类型的值</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="json-对象"></a><a href="#json-对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JSON 对象</h3>
<p>JSON 对象是一种用于原生 JSON 分析的对象，无法对其进行构造函数调用。如果用 Java 中的术语来说，它相当于能够直接使用类方法的工具类。也就是说 <code>JSON</code> 本身就是 JavaScript 中提供的一个内置对象，这个对象提供了一些 JSON 相关的 API。</p>
<p>JSON 对象的属性</p>
<table>
<thead>
<tr><th>属性名</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>parse(text[, reviver])</td><td>对参数 text 这一 JSON 字符串进行分析之后返回一个 JavaScript 对象。reviver 将会对每个属性调用回调函数，并将返回值赋为属性值</td></tr>
<tr><td>stringify(value[, replacer[, space]])</td><td>将参数 value 转换为 JSON 字符串。replacer 将会对每个属性调用回调函数，并 将返回值赋为属性值。space 则是输出时的一个缩进字符串</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="日期处理"></a><a href="#日期处理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>日期处理</h2>
<p>Date 类的函数以及构造函数调用</p>
<table>
<thead>
<tr><th>函数或是构造函数</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>Date()</td><td>返回当前时刻的字符串</td></tr>
<tr><td>new Date([year[, month[, date[, hours[, minutes[, seconds[, ms]]]]]]])</td><td>返回参数所指定的时刻的 Date 实例</td></tr>
<tr><td>new Date(value)</td><td>将参数作为 epoch 值并返回相应的 Date 实例</td></tr>
<tr><td>new Date()</td><td>返回当前时刻的 Date 实例</td></tr>
</tbody>
</table>
<p>需要注意的是，和其他一些程序设计语言一样，在 JavaScript 中，month 也是由 0 开始计数的。也就 是说，一个显示为 2012 年 1 月 1 日的 Date 对象应该以下面这样的方式生成。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> dt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2012</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 2012 年 1 月 1 日</span>
<span class="hljs-built_in">console</span>.log(dt.toString());
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-javascript">(py3<span class="hljs-number">.5</span>) czp@:~<span class="hljs-regexp">/workspace/</span>knowledge-base/demos/node_start$ node hello.js
Sun Jan <span class="hljs-number">01</span> <span class="hljs-number">2012</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT+<span class="hljs-number">0800</span> (中国标准时间)
</code></pre>
<blockquote>
<p>注：这里的时间都是代表着客户端的本地时间</p>
<p>也就是说同样一串代码 <code>var dt = new Date(2012,0,1);</code>，在中国执行，和在美国执行，实际上这两个 date 对象底层对应的绝对时间（或者说是相对于 0 时区的时间戳秒数），是不一样的</p>
</blockquote>
<p>Date.prototype 对象的属性</p>
<table>
<thead>
<tr><th>属性名</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>constructor</td><td>指向 Date 类对象的一个引用</td></tr>
<tr><td>getDate()</td><td>返回日期的数值。日期从 1 开始计。基于时间</td></tr>
<tr><td>getDay()</td><td>返回星期几的数值。一个星期从星期日开始计。星期日是 0，星期六是 6。基于 本地时间</td></tr>
<tr><td>getFullYear()</td><td>返回年的数值。基于本地时间</td></tr>
<tr><td>getHours()</td><td>返回小时的数值。小时从 0 开始计。基于本地时间</td></tr>
<tr><td>getMilliseconds()</td><td>返回毫秒的数值。毫秒数从 0 开始计。基于本地时间</td></tr>
<tr><td>getMinutes()</td><td>返回分的数值。分从 0 开始计。基于本地时间</td></tr>
<tr><td>getMonth()</td><td>返回月份的数值。月份从 0 开始计。1 月是 0，12 月是 11。基于本地时间</td></tr>
<tr><td>getSeconds()</td><td>返回秒的数值。秒从 0 开始计。基于本地时间</td></tr>
<tr><td>getTime()</td><td>返回一个数值形式的时间。即取得当前的 epoch 毫秒值</td></tr>
<tr><td>getTimezoneOffset()</td><td>返回时区的偏差量。单位是分钟</td></tr>
<tr><td>getUTCDate()</td><td>返回日期的数值。日期从 1 开始计。基于 UTC 时间</td></tr>
<tr><td>getUTCDay()</td><td>返回星期几的数值。一个星期从星期日开始计。星期日是 0，星期六是 6。基于 UTC 时间</td></tr>
<tr><td>getUTCFullYear()</td><td>返回年的数值。基于 UTC 时间</td></tr>
<tr><td>getUTCHours()</td><td>返回小时的数值。小时从 0 开始计。基于 UTC 时间</td></tr>
<tr><td>getUTCMinutes()</td><td>返回分的数值。分从 0 开始计。基于 UTC 时间</td></tr>
<tr><td>getUTCMonth()</td><td>返回月份的数值。月份从 0 开始计。1 月是 0，12 月是 11。基于 UTC 时间</td></tr>
<tr><td>getUTCSeconds()</td><td>返回秒的数值。秒从 0 开始计。基于 UTC 时间</td></tr>
<tr><td>getUTCMilliseconds()</td><td>返回毫秒的数值。秒从 0 开始计。基于 UTC 时间</td></tr>
<tr><td>setDate(date)</td><td>将日期设定为参数指定的值（1-31）。基于本地时间</td></tr>
<tr><td>setFullYear(year[, month[, date]])</td><td>将年份设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setHours(hour[, min[, sec[, ms]]])</td><td>将小时设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setMilliseconds(ms)</td><td>将年毫秒设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setMinutes(min[, sec[, ms]])</td><td>将分钟设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setMonth(month[, date])</td><td>将月份设定为参数指定的值（0-11）。基于本地时间</td></tr>
<tr><td>setSeconds(sec[, ms])</td><td>将秒设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setTime(time)</td><td>将 epoch 毫秒设定为参数指定的值。基于本地时间</td></tr>
<tr><td>setUTCDate(date)</td><td>将日期设定为参数指定的值（1-31）。基于 UTC 时间</td></tr>
<tr><td>setUTCFullYear(year[, month[, date]])</td><td>将年份设定为参数指定的值。基于 UTC 时间</td></tr>
<tr><td>setUTCHours(hour[, min[, sec[, ms]]])</td><td>将小时设定为参数指定的值。基于 UTC 时间</td></tr>
<tr><td>setUTCMilliseconds(ms)</td><td>将年毫秒设定为参数指定的值。基于 UTC 时间</td></tr>
<tr><td>setUTCMinutes(min[, sec[, ms]])</td><td>将分钟设定为参数指定的值。基于 UTC 时间</td></tr>
<tr><td>setUTCMonth(month[, date])</td><td>将月份设定为参数指定的值（0-11）。基于 UTC 时间</td></tr>
<tr><td>setUTCSeconds(sec[, ms])</td><td>将秒设定为参数指定的值。基于 UTC 时间</td></tr>
<tr><td>toDateString()</td><td>将 Date 实例的日期转换为字符串值。基于本地时间</td></tr>
<tr><td>toJSON(key)</td><td>将 Date 实例转换为 JSON 格式的字符串值</td></tr>
<tr><td>toISOString()</td><td>将 Date 实例转换为 ISO8601 格式的字符串值</td></tr>
<tr><td>toLocaleDateString()</td><td>将 Date 实例的日期转换为与地区相关的字符串值。基于本地时间</td></tr>
<tr><td>toLocaleFormat(format)</td><td>JavaScript 自定义的增强功能。以 format 字符串所指定的格式将日期转换为字符 串。基于本地时间</td></tr>
<tr><td>toLocaleString()</td><td>将 Date 实例转换为地区相关的字符串。基于本地时间</td></tr>
<tr><td>toLocaleTimeString()</td><td>将 Date 实例所表示的时刻转换为地区相关的字符串。基于地区相关时刻</td></tr>
<tr><td>toSource()</td><td>JavaScript 自定义的增强功能。返回用于生成 Date 实例的字符串（即源代码）</td></tr>
<tr><td>toString()</td><td>将 Date 实例转换为字符串值。基于本地时间</td></tr>
<tr><td>toTimeString()</td><td>将 Date 实例的时刻转换为字符串值。基于本地时间</td></tr>
<tr><td>toUTCString()</td><td>将 Date 实例转换为字符串值。基于 UTC 时间</td></tr>
<tr><td>valueOf()</td><td>将 Date 实例转换为数值。即取得当前的 epoch 毫秒值</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/21/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/函数"><span class="arrow-prev">← </span><span>函数</span></a><a class="docs-next button" href="/docs/nodejs/常用API"><span>常用 API</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#数组">数组</a><ul class="toc-headings"><li><a href="#数组-api">数组 API</a></li></ul></li><li><a href="#json">JSON</a><ul class="toc-headings"><li><a href="#json-的标准">JSON 的标准</a></li><li><a href="#json-对象">JSON 对象</a></li></ul></li><li><a href="#日期处理">日期处理</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>