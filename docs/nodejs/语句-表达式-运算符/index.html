<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要是说明一些 `Javascript` 中的一些语法元素，包括语句、表达式、运算符等"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要是说明一些 `Javascript` 中的一些语法元素，包括语句、表达式、运算符等"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/docusaurus/快速开始/install" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Node JS</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Docusaurus<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/install">安装运行</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/config">目录结构和配置</a></li><li class="navListItem"><a class="navItem" href="/docs/docusaurus/快速开始/build">构建并发布到 Github Pages</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node JS<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/语句-表达式-运算符.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要是说明一些 <code>Javascript</code> 中的一些语法元素，包括语句、表达式、运算符等</p>
<h2><a class="anchor" aria-hidden="true" id="6种循环（es-6）"></a><a href="#6种循环（es-6）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6种循环（ES 6）</h2>
<p>在 <code>Javascript</code> 中包含 6 种循环语句，<code>for each in</code> 语句在 <code>ECMAScrupt</code> 中并不存在，属于 <code>Javascript</code> 特有的增强功能。</p>
<ul>
<li><code>while (条件表达式)</code></li>
<li><code>do while (条件表达式)</code></li>
<li><code>for(初始化表达式;条件表达式;更新表达式)</code></li>
<li><code>for (变量 in 对象表达式)</code>（属性名迭代）</li>
<li><code>for each (变量 in 对象表达式)</code> （非 ES 标准，属性值迭代）</li>
<li><code>for (变量 of 对象表达式)</code>（ES 6 标准，属性值迭代，具体内容后续 ES 6 内容中进行补充）</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="for-循环"></a><a href="#for-循环" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>for 循环</h2>
<p>唯一的注意点：ES 6 之前，JS 没有块级作用域，所以 for 循环中声明的循环变量，在循环结束后依然是可以访问的，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    ; <span class="hljs-comment">// 什么都不干</span>
}
<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出 10，这里我们依然能访问到 i</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="for-in-语句"></a><a href="#for-in-语句" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>for in 语句</h2>
<p>for in 语句是用于枚举对象属性名的循环语句。在对象表达式处所写的<strong>对象的属性名</strong>的字符串，会被依次赋值给循环变量，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-comment">// 迭代的是属性名称而不是属性值</span>
    <span class="hljs-built_in">console</span>.log(k);
}
<span class="hljs-comment">// 依次输出 x y z (也可能不是这个顺序)</span>
</code></pre>
<p>如果想要输出属性值，一般使用 <code>obj[k]</code> 的方式进行迭代，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-built_in">console</span>.log(obj[k]);
}
<span class="hljs-comment">// 依次输出 1 3 2 (也可能不是这个顺序)</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="处理数列"></a><a href="#处理数列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理数列</h3>
<p>数列也是一种对象，而且下标值相当于一种属性名，所以可以像下面这样进行迭代（但是一般不推荐），例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * 输出
 * 0=&gt;7
 * 1=&gt;1
 * 2=&gt;5
 */</span>
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> arr) {
    <span class="hljs-built_in">console</span>.log(n + <span class="hljs-string">'=&gt;'</span> + arr[n]);
}
</code></pre>
<p>如果我们给数列对象加上了别的属性，那么加上的属性也会被迭代，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * 输出
 * 0=&gt;7
 * 1=&gt;1
 * 2=&gt;5
 * x=&gt;3
 */</span>
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];
arr.x = <span class="hljs-number">3</span>; <span class="hljs-comment">// 增加了一个 x 属性</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> arr) {
    <span class="hljs-built_in">console</span>.log(n + <span class="hljs-string">'=&gt;'</span> + arr[n]);
}
</code></pre>
<blockquote>
<p>注意：</p>
<ol>
<li><p>for in 的属性是不确定的，不能认为它有某种顺序规则，我们不应该依靠它的任何顺序，把它当成随机顺序即可。（虽然大部分情况会有相同的顺序，但是不能认为这一定是成立的）</p></li>
<li><p>for in 可以枚举由原型继承而来的属性</p></li>
<li><p>for in 有些属性是不能进行枚举的（enumerable = false 的属性，我们添加的常规属性都是 true，数组的 length 是 false）。也就是说，属性本身也是有属性的(或者可以称为元属性？)，就像在 Java 中，属性除了属性值外，还有可见性、是否 final 等一些其它的属性值之外的属性。在 Javascript 中，属性有 5 种元属性（在此只简单列举，后续会有详细分析）：</p>
<table>
<thead>
<tr><th>属性的属性名称</th><th>含义</th></tr>
</thead>
<tbody>
<tr><td>writable</td><td>可以改写属性值</td></tr>
<tr><td>enumerable</td><td>属性可以被 for in 语句枚举</td></tr>
<tr><td>configutable</td><td>元属性本身是否可以进行改变（就是说一个对象的某个属性的这 5 种元属性是否还能进行更改，configurable 一旦为 false，就再也不可改了）</td></tr>
<tr><td>get</td><td>设置属性值的 getter 函数</td></tr>
<tr><td>set</td><td>设置属性值的 setter 函数</td></tr>
</tbody>
</table>
</li>
</ol>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="错误处理"></a><a href="#错误处理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>错误处理</h2>
<p>我们可以用 <code>throw</code> 抛出异常，用 <code>try...catch</code> 捕获它（跟 Java 差不多）。</p>
<h3><a class="anchor" aria-hidden="true" id="错误类型"></a><a href="#错误类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>错误类型</h3>
<p>ES 标准定义了 7 种异常类型：</p>
<ul>
<li><code>Error</code></li>
<li><code>EvalError</code></li>
<li><code>RangeError</code></li>
<li><code>ReferenceError</code></li>
<li><code>SyntaxError</code></li>
<li><code>TypeError</code></li>
<li><code>URIError</code></li>
</ul>
<p>其中，<code>Error</code> 是以上所有异常的基类，包含 2 个属性：<code>name</code> 和 <code>message</code>，表示错误的名称和错误的信息。一般不会直接抛出 <code>Error</code>，而是会抛出子类型的错误。</p>
<ul>
<li><p><code>EvalError</code> 类型的错误现在不再会被抛出了（新的 ES 标准中）</p></li>
<li><p><code>RangeError</code> 会在数值超过相应范围时候抛出，例如定义数组时设置不支持的项数，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> items1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">-20</span>); <span class="hljs-comment">// 抛出 RangeError</span>
<span class="hljs-keyword">var</span> items2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Number</span>.MAX_VALUE);  <span class="hljs-comment">// 抛出 RangeError</span>
</code></pre></li>
<li><p><code>ReferenceError</code> 在使用不存在的变量时会抛出，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// a 从未声明过，会抛出 ReferenceError</span>
</code></pre></li>
<li><p><code>SyntaxError</code> 就是语法错误，这个不用多说明了</p></li>
<li><p><code>TypeError</code> 在变量类型不符合要求时出现，例如下面 3 行都会出现该错误：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"name"</span> <span class="hljs-keyword">in</span> <span class="hljs-literal">true</span>);
<span class="hljs-built_in">Function</span>.prototype.toString.call(<span class="hljs-string">"name"</span>);
</code></pre></li>
<li><p><code>URIError</code> 在使用 <code>encodeURI()</code> 或 <code>decodeURI()</code>，而 URI 格式不正确时，就会导致 <code>URIError</code> 错误。</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="trycatch-语句"></a><a href="#trycatch-语句" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>try...catch 语句</h3>
<p>例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">try</span> {
    <span class="hljs-built_in">console</span>.log(foo);
} <span class="hljs-keyword">catch</span> (someError) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'错误名称：'</span> + someError.name);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'错误信息：'</span> + someError.message);
}
</code></pre>
<p>finally 块的代码一定会最后执行，所以如果 finally 块中有返回语句，那么会覆盖前面的返回值。</p>
<p>我们可以处理不同类型的错误，使用如下方式：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">try</span> {
    someFunction();
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>) {
        <span class="hljs-comment">//处理</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>) {
        <span class="hljs-comment">//处理</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//处理其它类型错误</span>
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="throw-抛出错误"></a><a href="#throw-抛出错误" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>throw 抛出错误</h3>
<p><code>Javascript</code> 可以抛出任何类型和值的错误，也就是说，下面的代码都是有效的：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">throw</span> <span class="hljs-number">12345</span>; 
<span class="hljs-keyword">throw</span> <span class="hljs-string">"Hello world!"</span>; 
<span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>; 
<span class="hljs-keyword">throw</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">"JavaScript"</span>};
</code></pre>
<p>throw 之后的语句都不会执行，直到被捕获后在捕获的那一块儿代码中继续执行，例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'before throw'</span>);
    <span class="hljs-keyword">throw</span> <span class="hljs-number">100</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'after throw'</span>); <span class="hljs-comment">// 永远不会执行到这里</span>
}
<span class="hljs-keyword">try</span> {
    test();
} <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到：'</span> + error);
}
<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// before throw</span>
<span class="hljs-comment">// 捕获到：100</span>
</code></pre>
<p>使用内置错误，每种错误都接收一个参数，就是错误的信息：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"something wrong"</span>);
</code></pre>
<p>利用原型链可以创建自定义的错误类型，这个可以以后再研究</p>
<h2><a class="anchor" aria-hidden="true" id="new-运算符（mdn-文档：new-运算符httpsdevelopermozillaorgzh-cndocswebjavascriptreferenceoperatorsnew）"></a><a href="#new-运算符（mdn-文档：new-运算符httpsdevelopermozillaorgzh-cndocswebjavascriptreferenceoperatorsnew）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NEW 运算符（MDN 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">NEW 运算符</a>）</h2>
<p><code>new</code> 运算符会进行如下操作：</p>
<ol>
<li>创建一个空的简单 <code>JavaScript</code> 对象，也就是 <code>{}</code>，假设起一个临时名字是 <code>tmp</code></li>
<li>将新对象 <code>tmp</code> 的原型对象指向构造函数（假设是 <code>Func()</code> 函数）的 <code>prototype</code> 属性，也就是说 <code>tmp.__proto__ = Func.prototype</code></li>
<li>此时 <code>tmp.constructor = Func.prototype.constructor = Func</code></li>
<li>步骤 3 有两个关键，一个是 <code>tmp.constructor = Func</code>，一个是 <code>Func.prototype.constructor = Func</code>
<ul>
<li>也就是说新对象的 <code>constructor</code>是从原型链继承来的</li>
<li>函数对象的 <code>prototype</code> 属性上，有一个属性 <code>prototype.constructor</code> 指向函数对象自身</li>
</ul></li>
<li>调用新对象的 <code>constructor</code> 方法，也就是 <code>tmp.constructor(...)</code></li>
<li>步骤 5 的接收对象是 <code>tmp</code>，因此构造函数中 <code>this</code> 指向 <code>tmp</code></li>
<li>如果 <code>tmp.constructor(...)</code> 没有返回新对象，则返回 <code>this</code>，也就是 <code>tmp</code> 对象</li>
<li><code>new Func</code> 等同于 <code>new Func()</code>，也就是进行没有任何参数的构造函数调用</li>
</ol>
<p>示例：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">arg</span>) </span>{ <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>; <span class="hljs-built_in">console</span>.log(arg); }
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> a(); <span class="hljs-comment">// 输出 undefined</span>

<span class="hljs-comment">/**
 * b.constructor = b.__proto__.constructor 且 b.__proto__ = a.prototype
 * 因此 b.__proto__.constructor = a.prototype.constructor
 * 而 a.prototype.constructor = a 自身
 * 所以 b.constructor = a
 * 这里输出 [Function: a]
 */</span>
<span class="hljs-built_in">console</span>.log(b.constructor); 

b.__proto__ = <span class="hljs-built_in">Object</span>.prototype;

<span class="hljs-comment">/**
 * 此时 b.constructor = b.__proto__.constructor = Object.prototype.constructor
 * 因此 b.constructor = Object
 * 所以输出 [Function: Object]
 */</span>
<span class="hljs-built_in">console</span>.log(b.constructor);

a.prototype.constructor(<span class="hljs-number">11111</span>); <span class="hljs-comment">// 等价于 a(11111)调用，因此输出 11111</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="instanceof-运算符"></a><a href="#instanceof-运算符" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>INSTANCEOF 运算符</h2>
<p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。例如：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
<span class="hljs-comment">// true，Date.prototype = d.__proto__</span>
<span class="hljs-built_in">console</span>.log(d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>);
<span class="hljs-comment">// true，Object.prototype = Date.prototype.__proto__ = d.__proto__.__proto__</span>
<span class="hljs-built_in">console</span>.log(d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Derived</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Base</span>(<span class="hljs-params"></span>) </span>{}
Derived.prototype = <span class="hljs-keyword">new</span> Base();
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Derived();
<span class="hljs-comment">// true Derived.prototype = obj.__proto__</span>
<span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> Derived);
<span class="hljs-comment">// true Base.prototype = Derived.prototype.__proto__ = obj.__proto__.__proto__</span>
<span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> Base);
<span class="hljs-comment">//true 一样的道理</span>
<span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);
</code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/1/2019</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/数据类型转换"><span class="arrow-prev">← </span><span>数据类型转换</span></a><a class="docs-next button" href="/docs/nodejs/变量与对象"><span>变量与对象</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#6种循环（es-6）">6种循环（ES 6）</a></li><li><a href="#for-循环">for 循环</a></li><li><a href="#for-in-语句">for in 语句</a><ul class="toc-headings"><li><a href="#处理数列">处理数列</a></li></ul></li><li><a href="#错误处理">错误处理</a><ul class="toc-headings"><li><a href="#错误类型">错误类型</a></li><li><a href="#trycatch-语句">try...catch 语句</a></li><li><a href="#throw-抛出错误">throw 抛出错误</a></li></ul></li><li><a href="#new-运算符（mdn-文档：new-运算符httpsdevelopermozillaorgzh-cndocswebjavascriptreferenceoperatorsnew）">NEW 运算符（MDN 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">NEW 运算符</a>）</a></li><li><a href="#instanceof-运算符">INSTANCEOF 运算符</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>