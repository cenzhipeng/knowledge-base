<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文记录 UNIX 的一些基本知识。示例基本是用 node 写的，不是因为精通 node，是因为我最近在学 node 😄。其实我主力是搞 java 的"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文记录 UNIX 的一些基本知识。示例基本是用 node 写的，不是因为精通 node，是因为我最近在学 node 😄。其实我主力是搞 java 的"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/docusaurus/快速开始/install" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/UNIX进程/基础知识.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文记录 UNIX 的一些基本知识。示例基本是用 node 写的，不是因为精通 node，是因为我最近在学 node 😄。其实我主力是搞 java 的</p>
<h2><a class="anchor" aria-hidden="true" id="unix-手册页（manpages）"></a><a href="#unix-手册页（manpages）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UNIX 手册页（manpages）</h2>
<p>也就是我们的 <code>man</code> 命令，其实就是读取手册页的内容去了</p>
<p><code>man man</code>，查看关于 <code>man</code> 命令本身的内容</p>
<p>FreeBSD 和 Linux 系统手册页中最常用的节：</p>
<ul>
<li>节1：一般命令，也就是 shell 命令。例如 <code>find(1)</code> ，就代表去查找 <code>manpage</code> 里关于 <code>find</code> 命令的内容，我们就可以使用 <code>man 1 find</code> ，来查看命令的相关内容（等价于 <code>man find</code>）</li>
<li>节2：系统调用，例如 <code>getpid(2)</code> ，就代表去查找 <code>getpid</code> 这个系统调用，使用 <code>man 2 getpid</code> 来查看系统调用的相关内容</li>
<li>节3：C库函数，同理</li>
<li>节4：特殊文件，同理</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="进程id"></a><a href="#进程id" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进程ID</h2>
<p>在系统中运行的所有进程都有一个唯一的进程标示符，称为 <code>pid</code></p>
<p>node 获取 <code>pid</code> 十分简单：<code>console.log(process.pid);</code></p>
<p>bash 中还有个环境变量也保存着 <code>pid</code> ，那就是 <code>$$</code>，例如</p>
<pre><code class="hljs css language-bash">[vagrant@node node_start]$ <span class="hljs-built_in">echo</span> $$
18700
[vagrant@node node_start]$ ps
  PID TTY          TIME CMD
18700 pts/0    00:00:00 bash
18764 pts/0    00:00:00 ps
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="父进程"></a><a href="#父进程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>父进程</h2>
<p>系统中运行的每一个进程都有对应的父进程。每个进程都知道其父进程的标识符（称为 <code>ppid</code>）。</p>
<p>在多数情况下，特定进程的父进程就是<strong>调用它</strong>的那个进程。假设你是一名 OS X 用户，启动了终端并进入 <code>bash</code> 提示符。因为万物皆为进程，所以你刚才的举动便创建了一个新的<strong>终端进程</strong>，而新的终端进程又创建了一个 <strong>bash 进程</strong>。此时，<code>bash</code> 进程的父进程就是终端进程。如果我再从 <code>bash</code> 进程中使用 <code>ls</code> 命令，那么 <code>ls</code> 进程的父进程就是 <code>bash</code> 进程。</p>
<p>node 获取 <code>ppid</code> 也十分简单，如下：</p>
<pre><code class="hljs css language-bash">[vagrant@node node_start]$ ps
  PID TTY          TIME CMD
18700 pts/0    00:00:00 bash
18827 pts/0    00:00:00 ps
[vagrant@node node_start]$ node -p <span class="hljs-string">"process.ppid"</span>
18700
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="文件描述符"></a><a href="#文件描述符" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>文件描述符</h2>
<p>在 Unix世界中，万物皆为文件。这意味着可以将设备视为文件，将套接字和管道视为文件，将文件也视为文件。（一个 <code>socket</code> 在进程中就是一个文件描述符，一个 <code>pipe</code> 在进程中也是一个文件描述符）</p>
<h3><a class="anchor" aria-hidden="true" id="描述符代表资源"></a><a href="#描述符代表资源" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>描述符代表资源</h3>
<p>因为所有一切都被视为文件，所以当讨论一般意义上的文件（包括设备、管道、套接字等）时，我将使用“资源”这个词；当表示传统定义（文件系统中的文件）的时候，将使用“文件”这个词。</p>
<p>（也就是说 <strong>资源</strong> 代表着：文件、套接字、管道、设备）</p>
<p>无论何时在进程中打开一个资源，你都会获得一个文件描述符编号（file descriptor number）。文件描述符并不会在无关进程之间共享，它只存在于其所属的进程之中。当进程结束后，会和其他由进程所打开的资源一同被关闭。进程打开的所有资源都会获得一个用于标识的唯一数字。这便是内核跟踪进程所用资源的方法。</p>
<p>（也就是说我们打开一个资源的时候，会获取一个编号，而这个编号在内核中则对应着<strong>这个进程的文件描述符</strong>，不同进程的文件描述符毫不相干。进程结束时，所有资源会统一关闭）</p>
<p>node 中输出 标准输入、标准输出、标准错误的文件描述符编号：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">console</span>.log(process.stdin.fd);
<span class="hljs-built_in">console</span>.log(process.stdout.fd);
<span class="hljs-built_in">console</span>.log(process.stderr.fd);
</code></pre>
<p>输出：</p>
<pre><code class="hljs css language-bash">[vagrant@node node_start]$ node hello.js 
0
1
2
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>我们每次打开资源时，分配的文件描述符编号都是尚未使用的最小编号。例如我们刚刚启动一个进程的时候，分配的是 012 这 3 个必须有的资源，对应着标准输入、标准输出、标准错误。当我们打开一个文件时，将会分配 3 这个最小的编号</li>
<li>资源一旦关闭，对应的文件描述符编号就又能够使用了。例如，我们关闭了标准错误流，那么下次打开文件时，将会使用标准错误流原有的文件描述符编号，也就是 2</li>
<li>文件描述符只是用来跟踪打开的资源，已经关闭的资源是没有文件描述符的</li>
</ul>
<p>从内核的角度来看，此举意义重大。一旦资源被关闭，它就不再需要同硬件层打交道了，因此内核也就无需再对其进行跟踪。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="标准流"></a><a href="#标准流" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>标准流</h3>
<p>每个 Unix进程都有三个打开的资源，它们是</p>
<ul>
<li>标准输入（STDIN） 文件描述符编号：0</li>
<li>标准输出（STDOUT） 文件描述符编号：1</li>
<li>标准错（STDERR） 文件描述符编号：2</li>
</ul>
<p>这些标准资源是因为一个很重要的原因而存在，而如今我们已把这个原因视为理所当然。STDIN 提供了一种从键盘或管道中读取输入的通用方法，STDOUT 和 STDERR 提供了一种向显示器、文件、打印机等输出写入内容的通用方法。这是 Unix的一个创新。
在 STDIN 出现之前，为了能够支持键盘，你得在程序中列入一个键 盘驱动程序！而且如果想在屏幕上显示一些信息，你还得知道如何控 制所需的屏幕像素。所以我们要感谢标准流！</p>
<h2><a class="anchor" aria-hidden="true" id="资源限制"></a><a href="#资源限制" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源限制</h2>
<p>文件描述符代表已打开的资源。你可能注意到当资源没有被关闭时，文件描述符编号一直处于递增状态。这就产生一个问题：一个进程可以拥有多少个文件描述符？</p>
<p>答案取决于你的系统配置，不过重要的一点是：内核为进程施加了某些资源限制。</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 12/21/2019</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#unix-手册页（manpages）">UNIX 手册页（manpages）</a></li><li><a href="#进程id">进程ID</a></li><li><a href="#父进程">父进程</a></li><li><a href="#文件描述符">文件描述符</a><ul class="toc-headings"><li><a href="#描述符代表资源">描述符代表资源</a></li><li><a href="#标准流">标准流</a></li></ul></li><li><a href="#资源限制">资源限制</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>