---
id: 基础知识
title: 本文内容
sidebar_label: 基础知识
---

本文记录 UNIX 的一些基本知识。示例基本是用 node 写的，不是因为精通 node，是因为我最近在学 node 😄。其实我主力是搞 java 的



## UNIX 手册页（manpages）

也就是我们的 `man` 命令，其实就是读取手册页的内容去了

`man man`，查看关于 `man` 命令本身的内容

FreeBSD 和 Linux 系统手册页中最常用的节：

- 节1：一般命令，也就是 shell 命令。例如 `find(1)` ，就代表去查找 `manpage` 里关于 `find` 命令的内容，我们就可以使用 `man 1 find` ，来查看命令的相关内容（等价于 `man find`）
- 节2：系统调用，例如 `getpid(2)` ，就代表去查找 `getpid` 这个系统调用，使用 `man 2 getpid` 来查看系统调用的相关内容
- 节3：C库函数，同理
- 节4：特殊文件，同理



## 进程ID

在系统中运行的所有进程都有一个唯一的进程标示符，称为 `pid`

node 获取 `pid` 十分简单：`console.log(process.pid);`

bash 中还有个环境变量也保存着 `pid` ，那就是 `$$`，例如

```bash
[vagrant@node node_start]$ echo $$
18700
[vagrant@node node_start]$ ps
  PID TTY          TIME CMD
18700 pts/0    00:00:00 bash
18764 pts/0    00:00:00 ps
```



## 父进程

系统中运行的每一个进程都有对应的父进程。每个进程都知道其父进程的标识符（称为 `ppid`）。

在多数情况下，特定进程的父进程就是**调用它**的那个进程。假设你是一名 OS X 用户，启动了终端并进入 `bash` 提示符。因为万物皆为进程，所以你刚才的举动便创建了一个新的**终端进程**，而新的终端进程又创建了一个 **bash 进程**。此时，`bash` 进程的父进程就是终端进程。如果我再从 `bash` 进程中使用 `ls` 命令，那么 `ls` 进程的父进程就是 `bash` 进程。

node 获取 `ppid` 也十分简单，如下：

```bash
[vagrant@node node_start]$ ps
  PID TTY          TIME CMD
18700 pts/0    00:00:00 bash
18827 pts/0    00:00:00 ps
[vagrant@node node_start]$ node -p "process.ppid"
18700
```



## 文件描述符

在 Unix世界中，万物皆为文件。这意味着可以将设备视为文件，将套接字和管道视为文件，将文件也视为文件。（一个 `socket` 在进程中就是一个文件描述符，一个 `pipe` 在进程中也是一个文件描述符）



### 描述符代表资源

因为所有一切都被视为文件，所以当讨论一般意义上的文件（包括设备、管道、套接字等）时，我将使用“资源”这个词；当表示传统定义（文件系统中的文件）的时候，将使用“文件”这个词。

（也就是说 **资源** 代表着：文件、套接字、管道、设备）

无论何时在进程中打开一个资源，你都会获得一个文件描述符编号（file descriptor number）。文件描述符并不会在无关进程之间共享，它只存在于其所属的进程之中。当进程结束后，会和其他由进程所打开的资源一同被关闭。进程打开的所有资源都会获得一个用于标识的唯一数字。这便是内核跟踪进程所用资源的方法。

（也就是说我们打开一个资源的时候，会获取一个编号，而这个编号在内核中则对应着**这个进程的文件描述符**，不同进程的文件描述符毫不相干。进程结束时，所有资源会统一关闭）

node 中输出 标准输入、标准输出、标准错误的文件描述符编号：

```javascript
console.log(process.stdin.fd);
console.log(process.stdout.fd);
console.log(process.stderr.fd);
```

输出：

```bash
[vagrant@node node_start]$ node hello.js 
0
1
2
```



> 注意：
>
> - 我们每次打开资源时，分配的文件描述符编号都是尚未使用的最小编号。例如我们刚刚启动一个进程的时候，分配的是 012 这 3 个必须有的资源，对应着标准输入、标准输出、标准错误。当我们打开一个文件时，将会分配 3 这个最小的编号
> - 资源一旦关闭，对应的文件描述符编号就又能够使用了。例如，我们关闭了标准错误流，那么下次打开文件时，将会使用标准错误流原有的文件描述符编号，也就是 2 
> - 文件描述符只是用来跟踪打开的资源，已经关闭的资源是没有文件描述符的
>
> 从内核的角度来看，此举意义重大。一旦资源被关闭，它就不再需要同硬件层打交道了，因此内核也就无需再对其进行跟踪。



### 标准流

每个 Unix进程都有三个打开的资源，它们是

- 标准输入（STDIN） 文件描述符编号：0
- 标准输出（STDOUT） 文件描述符编号：1
- 标准错（STDERR） 文件描述符编号：2

这些标准资源是因为一个很重要的原因而存在，而如今我们已把这个原因视为理所当然。STDIN 提供了一种从键盘或管道中读取输入的通用方法，STDOUT 和 STDERR 提供了一种向显示器、文件、打印机等输出写入内容的通用方法。这是 Unix的一个创新。
在 STDIN 出现之前，为了能够支持键盘，你得在程序中列入一个键 盘驱动程序！而且如果想在屏幕上显示一些信息，你还得知道如何控 制所需的屏幕像素。所以我们要感谢标准流！



## 资源限制

文件描述符代表已打开的资源。你可能注意到当资源没有被关闭时，文件描述符编号一直处于递增状态。这就产生一个问题：一个进程可以拥有多少个文件描述符？

答案取决于你的系统配置，不过重要的一点是：内核为进程施加了某些资源限制。





