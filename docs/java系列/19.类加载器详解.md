---
id: 类加载器详解
title: 本文内容
sidebar_label: 类加载器详解
---



## 说明

本文的源码均来自于我的 Mac 上安装的 `adoptopenjdk-8.jdk` ，非 Oracle JDK，因此部分细节有可能与 Oracle JDK 8 有所不同，但是应该基本上来说都是一致的。

运行代码时，如果没有明确说明，那么均是使用了 IDEA 提供的 springboot 2.x 模板运行的，主要是为了方便。没有明确说明的时候，都是使用 IDE 的运行按钮去运行的代码，而不是打成 springboot 的 fat jar 运行的。

本文不是很权威，仅仅是说下我个人的理解，因为一直对类加载器这一块儿模模糊糊的，最近正好有时间看这一块儿的内容，决定好好记录一下自己的研究过程和研究成果。



## 参考

- [classLoader使用与原理分析](https://liuzhengyang.github.io/2016/09/28/classloader/)



## BootstrapClassLoader

这个类加载器实际上并不存在于 Java 中，它是由 C++ 编写的 JVM 实现的一部分，它的主要作用就是加载 JDK 的核心类库，以 `java.*` 开头的那些类（可能应该还有一些 sun 开头的类）。

当我们启动 JVM 的时候（视作一个用 C++ 写的普通的进程），BootstrapClassLoader（存在于 C++ 进程中）就会去加载 JDK 的核心类库，以前我们要配置 CLASSPATH 环境变量应该也是为了去告诉它去哪里加载核心类库所在的 jar 包。现在来说其实是不需要配置 CLASSPATH，JVM 会自动去找到核心类库的 jar 包路径（rt.jar），其实我猜测应该也就是相对于 java 命令本身所在的路径吧（../lib/rt.jar）

> 在我安装的 `adoptopenjdk-8.jdk` 中，实际上不存在 $JAVA_HOME/lib/rt.jar，只有 $JAVA_HOME/src.zip，BootstrapClassLoader 加载的是这个 zip 包里的核心类库。（jar包其实就是zip格式）



## sun.misc.Launcher

一直传说的类加载器的三层模型：BootstrapClassLoader ---> ExtClassLoader ---> AppClassLoader，其实后面 2 个 classLoader 都是 Launcher 的静态内部类。

首先看下 Launcher 的关键逻辑：

```java
public class Launcher {
  		// 关键逻辑，这里去调用构造函数构造一个实例了
  		private static Launcher launcher = new Launcher();
      public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                "Could not create extension class loader", e);
        }

        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                "Could not create application class loader", e);
        }

        // Also set the context class loader for the primordial thread.
        Thread.currentThread().setContextClassLoader(loader);

        // Finally, install a security manager if requested
        String s = System.getProperty("java.security.manager");
        if (s != null) {
            // init FileSystem machinery before SecurityManager installation
            sun.nio.fs.DefaultFileSystemProvider.create();

            SecurityManager sm = null;
            if ("".equals(s) || "default".equals(s)) {
                sm = new java.lang.SecurityManager();
            } else {
                try {
                    sm = (SecurityManager)loader.loadClass(s).newInstance();
                } catch (IllegalAccessException e) {
                } catch (InstantiationException e) {
                } catch (ClassNotFoundException e) {
                } catch (ClassCastException e) {
                }
            }
            if (sm != null) {
                System.setSecurityManager(sm);
            } else {
                throw new InternalError(
                    "Could not create SecurityManager: " + s);
            }
        }
    }
}
```

- `private static Launcher launcher = new Launcher();` 初始化的逻辑：
  - 因为 Launcher 属于核心类库，因此它被 BootstrapClassLoader 加载后执行了初始化，因此这里就调用构造方法构造了 Launcher 实例
- `public Launcher()` 构造方法的逻辑：
  1. 使用 [`ExtClassLoader.getExtClassLoader()`](#getExtClassLoader 方法) 构造 ExtClassLoader 实例
  2. 使用 [`loader = AppClassLoader.getAppClassLoader(extcl);`](#getAppClassLoader 方法)

### ExtClassLoader

ExtClassLoader 是用来加载以 `javax.*` 开头的那些 java 扩展类库，这些类库的 jar 包存在于 `$JAVA_HOME/jre/lib/ext` 目录下，说白了这个 ExtClassLoader 就是专门去加载这个路径下的 jar 包的，我们把自己的 jar 包扔到这个路径下面也会被它加载

先来看看它的初始化和构造的逻辑：

```java
static class ExtClassLoader extends URLClassLoader {
    static {
        ClassLoader.registerAsParallelCapable();
    }
    private static volatile ExtClassLoader instance = null;
            public static ExtClassLoader getExtClassLoader() throws IOException
        {
            if (instance == null) {
                synchronized(ExtClassLoader.class) {
                    if (instance == null) {
                        instance = createExtClassLoader();
                    }
                }
            }
            return instance;
        }

    private static ExtClassLoader createExtClassLoader() throws IOException {
        try {
            // Prior implementations of this doPrivileged() block supplied
            // aa synthesized ACC via a call to the private method
            // ExtClassLoader.getContext().

            return AccessController.doPrivileged(
                new PrivilegedExceptionAction<ExtClassLoader>() {
                    public ExtClassLoader run() throws IOException {
                        final File[] dirs = getExtDirs();
                        int len = dirs.length;
                        for (int i = 0; i < len; i++) {
                            MetaIndex.registerDirectory(dirs[i]);
                        }
                        return new ExtClassLoader(dirs);
                    }
                });
        } catch (java.security.PrivilegedActionException e) {
            throw (IOException) e.getException();
        }
    }
}
```

#### getExtClassLoader 方法

### AppClassLoader

#### getAppClassLoader 方法