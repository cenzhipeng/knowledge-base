<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 内置注解"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## 内置注解"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/java系列/1.java注解.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="内置注解"></a><a href="#内置注解" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内置注解</h2>
<p>java 本身有些内置注解，例如 Override、Deprecated、SuppressWarnings 等</p>
<h3><a class="anchor" aria-hidden="true" id="override"></a><a href="#override" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Override</h3>
<p>用来修饰方法，表示该方法应该是父类或者实现的接口中声明的，当前类重写该方法，如果父类或者实现的接口中没有这个方法，就会报错。</p>
<blockquote>
<p>这个注解加不加都不影响重写的结果，但是加了之后可以多一些编译时的检查，这样当我们写错方法名或者方法参数的时候可以被检查出来</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="deprecated"></a><a href="#deprecated" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deprecated</h3>
<p>它可以修饰类、方法、字段、参数等，表示对应的内容已经过时了，建议不要使用。</p>
<p>从 Java 9 开始，有 2 个参数：since 和 forRemoval，表示过时的起始以及将来是否删除。</p>
<p><img src="../assets/image-20200309144926803.png" alt="image-20200309144926803"></p>
<h3><a class="anchor" aria-hidden="true" id="supresswarnings"></a><a href="#supresswarnings" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SupressWarnings</h3>
<p>表示压制编译器的警告，有一个必填参数，表示压制哪种类型的编译警告。</p>
<p><img src="../assets/image-20200309145037607.png" alt="image-20200309145037607"></p>
<h2><a class="anchor" aria-hidden="true" id="注解的基本格式"></a><a href="#注解的基本格式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注解的基本格式</h2>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Target</span>({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings {
    String[] value();
}
</code></pre>
<p>上面是 SuppressWarnings 的代码。</p>
<ul>
<li>使用 <code>@interface</code></li>
<li>使用 <strong>元注解</strong> Target 和 Retention</li>
<li>注解中可以有一些方法，表示参数</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="target-目标"></a><a href="#target-目标" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Target 目标</h3>
<p>表示注解的目标，也就是当前定义的这个注解（Override）要注解在什么元素上，元素 ElementType 主要的有：</p>
<ul>
<li>TYPE：类、接口（包括注解），枚举</li>
<li>FIELD：字段，包括枚举常量</li>
<li>METHOD：方法</li>
<li>PARAMETER：方法中的参数</li>
<li>CONSTRUCTOR：构造方法</li>
<li>LOCAL_VARIABLE：本地变量</li>
<li>MODULE：模块（Java 9 引入）</li>
</ul>
<p>目标可以有多个，使用大括号 <code>{}</code> 来放置多个，表示当前定义的这个注解可以用在多个位置</p>
<blockquote>
<p>如果没有这个元注解，那我们当前定义的这个注解就是适用于所有位置</p>
<p>还有其他一些没有列举出来，参见 ElementType 枚举去看吧</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="retention-保留时间"></a><a href="#retention-保留时间" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retention 保留时间</h3>
<p>表示注解信息保留到什么时候，RetentionPolicy 可以取 3 种值：</p>
<ul>
<li>SOURCE：只在源代码种保留，编译成字节码之后就丢弃</li>
<li>CLASS：保留到字节码文件，但是 JVM 加载了该类之后，不一定保留这个注解信息</li>
<li>RUNTIME：一直保留到运行时，也就是说我们可以在运行的时候获取到注解的信息</li>
</ul>
<blockquote>
<p>如果没有声明 Retention，则表示是 CLASS 级别</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="documented-文档"></a><a href="#documented-文档" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Documented 文档</h3>
<p>功能：指明修饰的注解，可以被例如javadoc此类的工具文档化，只负责标记，没有成员取值。</p>
<h3><a class="anchor" aria-hidden="true" id="注解参数"></a><a href="#注解参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注解参数</h3>
<p>可以为注解定义一些参数，定义的方式是在注解内定义一些方法，比如 SuppressWarnings 中的 value() 方法，返回值表示参数的类型，也就是说这个注解可以接受一个字符串数组</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Target</span>({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings {
    String[] value();
}
</code></pre>
<blockquote>
<p>当只有一个参数，且名称是 value，提供参数的时候可以省略 <code>value=</code>，直接写参数值</p>
<p>例如 @SuppressWarnings({&quot;unused&quot;,&quot;deprecation&quot;})</p>
</blockquote>
<p>注解参数有限定的类型，只能是：基本类型、String、Class、枚举、注解，以及这些类型的数组</p>
<p>参数定义的时候可以有默认值，使用 default 来定义，例如</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Target</span>({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation {
    <span class="hljs-function">Boolean <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;
}
</code></pre>
<blockquote>
<p>参数值不能是 null</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="注解的继承"></a><a href="#注解的继承" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注解的继承</h2>
<p>实际上，注解不能继承，注解的继承表示的是使用该注解的类可以被继承</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemoApplication</span> </span>{
    <span class="hljs-meta">@Inherited</span>
    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
    <span class="hljs-meta">@interface</span> InheritedAnnotation {

    }

    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
    <span class="hljs-meta">@interface</span> UnInheritedAnnotation {

    }

    <span class="hljs-meta">@InheritedAnnotation</span>
    <span class="hljs-meta">@UnInheritedAnnotation</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{
    }


    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(Child<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAnnotationPresent</span>(<span class="hljs-title">InheritedAnnotation</span>.<span class="hljs-title">class</span>))</span>; <span class="hljs-comment">// true</span>
        System.out.println(Child<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAnnotationPresent</span>(<span class="hljs-title">UnInheritedAnnotation</span>.<span class="hljs-title">class</span>))</span>; <span class="hljs-comment">// false</span>
    }
}
</code></pre>
<blockquote>
<p>两个注解都在父类上添加了，都保留到运行时</p>
<p>子类继承父类后，只有添加了 Inherited 元注解的 InheritedAnnotation 在子类中还存在，而 UnInheritedAnnotation 不在子类中了</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="运行时获取注解信息"></a><a href="#运行时获取注解信息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>运行时获取注解信息</h2>
<p>添加了注解之后，实际上不会不对程序产生其它任何影响，我们需要执行一些运行时获取到注解信息的代码，然后再根据注解信息执行相关的操作，一般模式就是：添加注解、读取注解、执行相关操作</p>
<h3><a class="anchor" aria-hidden="true" id="反射获取注解信息"></a><a href="#反射获取注解信息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>反射获取注解信息</h3>
<p>Class、Field、Method、Constructor 都有如下关于注解的方法</p>
<ul>
<li><code>public Annotation[] getAnnotations()</code>：获取本元素的所有注解</li>
<li><code>public Annotation[] getDeclaredAnnotations()</code>：获取本元素的所有注解，不包括 <code>@Inherited</code> 继承来的</li>
<li><code>public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code>：获取指定类型的注解，没有的话返回 null</li>
<li><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>：判断是否具有指定类型的注解</li>
</ul>
<blockquote>
<p>这里都是 RUNTIME 类型的注解。有的 CLASS 或者 SOURCE 级别的，需要在外部进行处理，比如 Lombok 插件的注解就是 SOURCE 级别的，经过 Lombok 处理后，才能被 javac 编译器编译</p>
</blockquote>
<p>对于 Method 和 Constructor，他们都有参数，具有下面的方法：</p>
<ul>
<li><code>public Annotation[][] getParameterAnnotations()</code>：返回值是一个二维数组，每个参数对应一个一维数组，表示这个参数的所有注解</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="annotation-接口"></a><a href="#annotation-接口" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotation 接口</h3>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Annotation</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;

    Class&lt;? extends Annotation&gt; annotationType();
}
</code></pre>
<p>它表示注解，在内部实现时，所有的注解其实都实现了 Annotation 接口</p>
<h2><a class="anchor" aria-hidden="true" id="自定义注解-自定义序列化"></a><a href="#自定义注解-自定义序列化" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自定义注解-自定义序列化</h2>
<p>说一下大致的思路：</p>
<ul>
<li>创建一些自定义注解，例如 SerializedFieldName 控制序列化的字段的名称</li>
<li>将自定义注解 SerializedFieldName 放到类的字段上，输入参数表示字段的序列化名称</li>
<li>创建一个序列化器
<ul>
<li>序列化器接受一个对象</li>
<li>扫描对象的所有字段</li>
<li>扫描所有字段的注解</li>
<li>如果没有 SerializedFieldName 注解，就使用字段的原始名称进行序列化</li>
<li>如果有 SerializedFieldName 注解，就使用 SerializedFieldName 传入的名称进行序列化</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="repeatable-可重复注解"></a><a href="#repeatable-可重复注解" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Repeatable 可重复注解</h2>
<p>先看不能重复添加的普通注解：</p>
<p><img src="../assets/image-20200310165937423.png" alt="image-20200310165937423"></p>
<p>可以看到，添加一样的注解后会报错，提示我们，这个注解需要添加 Repeatable 元注解</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemoApplication</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(Repeat<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAnnotationPresent</span>(<span class="hljs-title">RepeatableAnnotation</span>.<span class="hljs-title">class</span>))</span>; <span class="hljs-comment">// false</span>
        System.out.println(Repeat<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAnnotationPresent</span>(<span class="hljs-title">RepeatableAnnotationContainer</span>.<span class="hljs-title">class</span>))</span>; <span class="hljs-comment">// true</span>
        RepeatableAnnotationContainer[] container =
                Repeat<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getAnnotationsByType</span>(<span class="hljs-title">RepeatableAnnotationContainer</span>.<span class="hljs-title">class</span>)</span>;
        RepeatableAnnotation[] repeats = container[<span class="hljs-number">0</span>].value();
        System.out.println(repeats[<span class="hljs-number">0</span>].value()); <span class="hljs-comment">// 第一个注解</span>
        System.out.println(repeats[<span class="hljs-number">1</span>].value()); <span class="hljs-comment">// 第二个注解</span>
    }
}

<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Repeatable</span>(RepeatableAnnotationContainer<span class="hljs-class">.<span class="hljs-keyword">class</span>)
@<span class="hljs-title">interface</span> <span class="hljs-title">RepeatableAnnotation</span> </span>{
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@interface</span> RepeatableAnnotationContainer {
    RepeatableAnnotation[] value();
}

<span class="hljs-meta">@RepeatableAnnotation</span>(<span class="hljs-string">"第一个注解"</span>)
<span class="hljs-meta">@RepeatableAnnotation</span>(<span class="hljs-string">"第二个注解"</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repeat</span> </span>{
}
</code></pre>
<p>主要的用法：</p>
<ul>
<li>将我们想要重复添加的注解 A 上添加上 Repeatable 元注解</li>
<li>Repeatable 元注解的参数是一个容器类注解 B，这个容器类注解 B 的 value 返回 A 数组，用来装载重复的 A 注解</li>
<li>当我们获取重复注解的时候，被注解了的 Repeat 类只有容器类注解 B，没有原始的重复注解 A，这些重复的 A 注解需要从容器类注解 B 的 value 方法中获取</li>
<li>另外，如果只有一个重复注解的时候，被注解的并不是容器类注解 B，而是就是原始的重复注解 A，所以我们需要注意这种情况</li>
</ul>
<blockquote>
<p>本质上是一个语法糖，最后被注解上的其实是容器类注解</p>
<p>小技巧是将容器类注解作为外部重复注解的内部注解类，也就是说把容器类注解的定义，放在原始的重复注解内部</p>
</blockquote>
<p>参考：<a href="https://www.jianshu.com/p/4f65fae2510b">Repeatable</a></p>
<h2><a class="anchor" aria-hidden="true" id="总结"></a><a href="#总结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>
<ul>
<li>注解具有保留期：源码、字节码、运行时。大部分框架都是使用运行时 RUNTIME 的注解</li>
<li>注解具有参数：可以给注解传入一些参数</li>
<li>单单只是注解的话不会对程序产生任何影响</li>
<li>一般的模式是扫描出注解，然后对注解做相应的处理</li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 3/12/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#内置注解">内置注解</a><ul class="toc-headings"><li><a href="#override">Override</a></li><li><a href="#deprecated">Deprecated</a></li><li><a href="#supresswarnings">SupressWarnings</a></li></ul></li><li><a href="#注解的基本格式">注解的基本格式</a><ul class="toc-headings"><li><a href="#target-目标">Target 目标</a></li><li><a href="#retention-保留时间">Retention 保留时间</a></li><li><a href="#documented-文档">Documented 文档</a></li><li><a href="#注解参数">注解参数</a></li></ul></li><li><a href="#注解的继承">注解的继承</a></li><li><a href="#运行时获取注解信息">运行时获取注解信息</a><ul class="toc-headings"><li><a href="#反射获取注解信息">反射获取注解信息</a></li><li><a href="#annotation-接口">Annotation 接口</a></li></ul></li><li><a href="#自定义注解-自定义序列化">自定义注解-自定义序列化</a></li><li><a href="#repeatable-可重复注解">Repeatable 可重复注解</a></li><li><a href="#总结">总结</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>