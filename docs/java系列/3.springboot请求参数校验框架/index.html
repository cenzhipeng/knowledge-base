<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 参考"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## 参考"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/java系列/3.springboot请求参数校验框架.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="参考"></a><a href="#参考" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考</h2>
<p><a href="https://juejin.im/post/5d3fbeb46fb9a06b317b3c48#heading-6">https://juejin.im/post/5d3fbeb46fb9a06b317b3c48#heading-6</a></p>
<h2><a class="anchor" aria-hidden="true" id="jsr303"></a><a href="#jsr303" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JSR303</h2>
<p>JSR303 是一套校验注解，位于 javax.validation 包下。</p>
<p>它只是规定了校验的一些规则，但是没有提供校验的具体实现，hibernate validation 提供了相应的实现，还提供了一些增加的注解给我们使用，Spring MVC 也支持校验，并且对 hibernate validation 进行了二次封装。使得我们只需要提供注解信息即可对参数进行校验</p>
<h2><a class="anchor" aria-hidden="true" id="校验注解列表"></a><a href="#校验注解列表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>校验注解列表</h2>
<table>
<thead>
<tr><th>验证注解</th><th>被注解的类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>@AssertFalse</td><td>Boolean,boolean</td><td>验证注解的元素值必须是false</td></tr>
<tr><td>@AssertTrue</td><td>Boolean,boolean</td><td>验证注解的元素值必须是true</td></tr>
<tr><td>@NotNull</td><td>任意类型</td><td>验证注解的元素值不是null</td></tr>
<tr><td>@Null</td><td>任意类型</td><td>验证注解的元素值是null</td></tr>
<tr><td>@Min(value=值)             </td><td>BigDecimal，BigInteger， byte，short， int， long，等任何Number 或 CharSequence（存储的是数字）子类型</td><td>验证注解的元素值大于等于@Min指定的value值</td></tr>
<tr><td>@Max(value=值)</td><td>和 @Min 一样</td><td>验证注解的元素值小于等于@Max指定的value值</td></tr>
<tr><td>@DecimalMin(value=值)                    </td><td>和 @Min 一样</td><td>验证注解的元素值大于等于@ DecimalMin指定的value值</td></tr>
<tr><td>@Digits(integer=整数位数, fraction=小数位数)</td><td>和 @Min 一样</td><td>被注释的元素必须是一个数字，验证元素值的整数位数和小数位数上限</td></tr>
<tr><td>@Size(min=下限, max=上限)</td><td>字符串、Collection、Map、数组等</td><td>验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小。新版和旧版好像行为不一致，旧版的行为似乎会同时对数组进行非空校验</td></tr>
<tr><td>@Past</td><td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td><td>验证注解的元素值（日期类型）比当前时间早</td></tr>
<tr><td>@Future</td><td>与@Past要求一样</td><td>验证注解的元素值（日期类型）比当前时间晚</td></tr>
<tr><td>@NotBlank</td><td>CharSequence子类型</td><td>验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的首位空格</td></tr>
<tr><td>@Length(min=下限, max=上限)</td><td>CharSequence子类型</td><td>验证注解的元素值长度在min和max区间内</td></tr>
<tr><td>@NotEmpty</td><td>CharSequence子类型、Collection、Map、数组</td><td>验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td></tr>
<tr><td>@Range(min=最小值, max=最大值)</td><td>BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型</td><td>验证注解的元素值在最小值和最大值之间</td></tr>
<tr><td>@Email(regexp=正则表达式,flag=标志的模式)</td><td>CharSequence子类型（如String）</td><td>验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式</td></tr>
<tr><td>@Pattern(regexp=正则表达式,flag=标志的模式)</td><td>String，任何CharSequence的子类型</td><td>验证注解的元素值与指定的正则表达式匹配</td></tr>
<tr><td>@Valid</td><td>任何非原子类型</td><td>指定递归验证关联的对象如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="springboot-校验使用方式"></a><a href="#springboot-校验使用方式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>springboot 校验使用方式</h2>
<h3><a class="anchor" aria-hidden="true" id="简单使用方式"></a><a href="#简单使用方式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简单使用方式</h3>
<pre><code class="hljs css language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@Validated HelloDTO helloDTO)</span> </span>{
  <span class="hljs-keyword">return</span> helloDTO.getStrArr();
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDTO</span> </span>{
    <span class="hljs-meta">@Size</span>(max = <span class="hljs-number">3</span>)
    <span class="hljs-keyword">private</span> String[] strArr;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：[<span class="hljs-string">"x"</span>,<span class="hljs-string">"x"</span>,<span class="hljs-string">"y"</span>]

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y&amp;strArr=c
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：校验异常
</code></pre>
<p>最简单的使用方式步骤：</p>
<ul>
<li>在入参的 DTO 类的字段上添加校验注解</li>
<li>在 controller 中方法参数上添加 @Validated 注解</li>
</ul>
<p>可以看到，这种方式十分简单</p>
<h3><a class="anchor" aria-hidden="true" id="校验结果参数"></a><a href="#校验结果参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>校验结果参数</h3>
<pre><code class="hljs css language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@Validated HelloDTO helloDTO, BindingResult bindingResult)</span> </span>{
  <span class="hljs-keyword">if</span>(bindingResult.hasErrors()){
    <span class="hljs-keyword">return</span> bindingResult.getFieldError().getField() + bindingResult.getFieldError().getDefaultMessage();
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"no problem"</span>;
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDTO</span> </span>{
    <span class="hljs-meta">@Size</span>(max = <span class="hljs-number">3</span>)
    <span class="hljs-keyword">private</span> String[] strArr;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y&amp;strArr=c
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl

结果：strArr个数必须在0和3之间

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：<span class="hljs-literal">no</span> problem
</code></pre>
<p>我们可以在校验的模型后面加上 BindingResult 获取本次校验的结果，如果校验多个模型参数，controller 方法的参数应该如下</p>
<p><code>public Object xxxFunc(@Validated Model1 model1, BindingResult result1, @Validated Model2 model2, BindingResult result2)</code></p>
<p>校验结果参数都紧跟在校验模型参数的后面</p>
<h3><a class="anchor" aria-hidden="true" id="分组校验"></a><a href="#分组校验" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分组校验</h3>
<p>有时候，controller 的几个方法入参模型都是一样的，但是校验规则不一样，这个是很常见的。</p>
<p>比如说添加一个用户和更新一个用户信息，它们都需要传入一个 User(id, name, address) 模型进来，但是校验规则不同：</p>
<ul>
<li>对于添加用户功能来说，不需要传入 id，但是需要传入 name、address 等必填信息</li>
<li>对于更新用户信息来说，需要传入 id，但是不需要传入 name、address 等信息，填 name 表示要覆盖原有的 name，填 address 表示要覆盖原有的 address，都不填就不做更改</li>
</ul>
<p>因此，为了满足这种常见的需求，可以使用分组的功能来校验</p>
<pre><code class="hljs css language-java">@GetMapping("/helloA")
public Object helloA(@Validated(HelloDTO.A.class) HelloDTO helloDTO, BindingResult bindingResult) {
  if(bindingResult.hasErrors()){
    return bindingResult.getFieldError().getField() + bindingResult.getFieldError().getDefaultMessage();
  }
  return "no problem";
}
@GetMapping("/helloB")
public Object helloB(@Validated(HelloDTO.B.class) HelloDTO helloDTO, BindingResult bindingResult) {
  if(bindingResult.hasErrors()){
    return bindingResult.getFieldError().getField() + bindingResult.getFieldError().getDefaultMessage();
  }
  return "no problem";
}

@Data
public class HelloDTO {
    public interface A{}
    public interface B{}
    @Size(max = 3,groups = A.class)
    @Size(max = 5,groups = B.class)
    private String[] strArr;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/helloA?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：<span class="hljs-literal">no</span> problem

<span class="hljs-builtin-name">GET</span> localhost:8080/helloB?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：<span class="hljs-literal">no</span> problem

<span class="hljs-builtin-name">GET</span> localhost:8080/helloA?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y&amp;strArr=c
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：strArr个数必须在0和3之间

<span class="hljs-builtin-name">GET</span> localhost:8080/helloB?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y&amp;strArr=c
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：<span class="hljs-literal">no</span> problem

<span class="hljs-builtin-name">GET</span> localhost:8080/helloB?<span class="hljs-attribute">strArr</span>=x&amp;strArr=x&amp;strArr=y&amp;strArr=c&amp;strArr=c&amp;strArr=c
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：strArr个数必须在0和5之间
</code></pre>
<p>分组校验的使用方法如上，步骤是：</p>
<ul>
<li>DTO 内部添加多个内部公共空接口，上述例子是 A 和 B</li>
<li>DTO 内部字段的校验注解添加 groups 信息
<ul>
<li><code>@Size(max = 3,groups = A.class)</code> 表示这个校验只在 A 组生效，数组长度最大是 3</li>
<li><code>@Size(max = 5,groups = B.class)</code> 表示这个校验只在 B 组生效，数组长度最大是 5</li>
</ul></li>
<li>@Validated 注解添加 groups 信息，表示要按照什么规则进行校验
<ul>
<li><code>@Validated(HelloDTO.A.class) HelloDTO helloDTO</code> 表示按照 A 组规则校验</li>
<li><code>@Validated(HelloDTO.B.class) HelloDTO helloDTO</code> 表示按照 B 组规则校验</li>
</ul></li>
<li>以上的分组，均可以是数组，也就是说，可以写成是
<ul>
<li><code>@Size(max = 3,groups = {A.class,B.class})</code> 表示这个校验规则在 AB 组规则下都生效</li>
<li><code>@Validated({HelloDTO.A.class,HelloDTO.B.class})</code> 表示按照 A 组和 B 组的规则都校验，也就是说这两组的规则全都要满足才校验通过</li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="对非-dto-的单个参数进行校验"></a><a href="#对非-dto-的单个参数进行校验" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对非 DTO 的单个参数进行校验</h3>
<p>上面的校验都是对 DTO 内部的字段进行校验，有时候我们使用的是单个参数，没有使用 DTO 对象，这种情况下校验的使用方式有些不同：</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Validated</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>{
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@Size(max = <span class="hljs-number">5</span>)</span> String str) </span>{
        <span class="hljs-keyword">return</span> str;
    }
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=aa
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：aa

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=aaccccc
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：错误
</code></pre>
<p>校验非模型的单个参数，步骤如下：</p>
<ul>
<li>@Validated 注解必须标注在 Controller 的类声明上，不是方法参数了。</li>
<li>@Size(max = 5) 这种校验注解标注在要验证的单个参数前，如上就是
<ul>
<li><code>public Object hello(@Size(max = 5) String str)</code></li>
</ul></li>
<li>这种验证方式没有 BindingResult 来接收结果了，BindingResult 仅用于模型的绑定结果</li>
<li>类上面添加 @Validated 注解仅仅影响这种单体参数的校验，不影响模型参数的校验</li>
<li>尽量少用这种方式</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="valid-注解内部对象嵌套校验"></a><a href="#valid-注解内部对象嵌套校验" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>@Valid 注解内部对象嵌套校验</h3>
<p>比如我们现在有个 OneDTO，本身有自己的校验规则，OneDTO 内部持有 AnotherDTO，AnotherDTO 也有自己的校验规则，controller 接收 OneDTO 的时候，同时要校验 OneDTO 本身，以及 OneDTO 内部的 AnotherDTO，就可以使用 @Valid 注解。</p>
<p>先看下没使用 @Valid 的情况</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@Validated OneDTO oneDTO)</span> </span>{
  <span class="hljs-keyword">return</span> oneDTO.getOne() + <span class="hljs-string">","</span> + oneDTO.getAnotherDTO().getAnother();
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDTO</span> </span>{
    <span class="hljs-meta">@Max</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">private</span> Integer one;
    <span class="hljs-keyword">private</span> AnotherDTO anotherDTO;
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherDTO</span> </span>{
    <span class="hljs-meta">@Min</span>(<span class="hljs-number">200</span>)
    <span class="hljs-keyword">private</span> Integer another;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">one</span>=1&amp;anotherDTO.another=3
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：1,3

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">one</span>=111&amp;anotherDTO.another=3
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：错误
</code></pre>
<p>可以看到，不在 OneDTO 中的 anotherDTO 属性上添加 @Valid 时，仅仅是校验了 <a href="http://OneDTO.one">OneDTO.one</a> 属性最大值上线是 100，没有校验 anotherDTO.another 必须大于等于 200。</p>
<p>下面添加 @Valid 注解</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDTO</span> </span>{
    <span class="hljs-meta">@Max</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">private</span> Integer one;
    <span class="hljs-meta">@Valid</span>
    <span class="hljs-keyword">private</span> AnotherDTO anotherDTO;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">one</span>=1&amp;anotherDTO.another=3
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：错误

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">one</span>=1&amp;anotherDTO.another=333
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：1,333
</code></pre>
<p>可以看到，anotherDTO 的校验规则也生效了</p>
<h3><a class="anchor" aria-hidden="true" id="小技巧-使用-valid-校验内部的-list-参数"></a><a href="#小技巧-使用-valid-校验内部的-list-参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小技巧 使用 @Valid 校验内部的 List 参数</h3>
<pre><code class="hljs css language-java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@RequestBody @Validated OneDTO oneDTO)</span> </span>{
  <span class="hljs-keyword">return</span> oneDTO;
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDTO</span> </span>{
    <span class="hljs-meta">@Max</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">private</span> Integer one;
    <span class="hljs-meta">@Valid</span>
    <span class="hljs-keyword">private</span> List&lt;AnotherDTO&gt; anotherDTO;
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherDTO</span> </span>{
    <span class="hljs-meta">@Min</span>(<span class="hljs-number">200</span>)
    <span class="hljs-keyword">private</span> Integer another;
}
</code></pre>
<p>使用如上的方式，就可以校验内部 List 的参数里的 AnotherDTO 模型了。</p>
<p>有时候可能一个 DTO 内部的 list 是 <code>List&lt;String&gt;</code> 或者 <code>List&lt;Integer&gt;</code> 这种装载的非 Model 类型，这个时候我们可以改造一下，改成只有单个属性的 Model，例如</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">//改造前</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDTO</span> </span>{
    <span class="hljs-meta">@Max</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">private</span> Integer one;
    <span class="hljs-keyword">private</span> List&lt;Integer&gt; anotherDTO;
}
</code></pre>
<pre><code class="hljs css language-java"><span class="hljs-comment">// 改造后</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDTO</span> </span>{
    <span class="hljs-meta">@Max</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">private</span> Integer one;
    <span class="hljs-meta">@Valid</span>
    <span class="hljs-keyword">private</span> List&lt;AnotherDTO&gt; anotherDTO;
}

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherDTO</span> </span>{
    <span class="hljs-meta">@Min</span>(<span class="hljs-number">200</span>)
    <span class="hljs-keyword">private</span> Integer another;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="自定义校验注解"></a><a href="#自定义校验注解" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自定义校验注解</h2>
<p>springboot 提供了自定义校验的接口，可以让我们完成自定义校验的功能。</p>
<p>下面以开发一个自定义校验注解 @MaxBytes 为例，它声明在一个 String 类型的字段上，注解有一个参数值，表示这个 String 的字节数大小不能超过这个参数值。（@Size 注解只能定义字符数量，有时候是不满足需求的）</p>
<h3><a class="anchor" aria-hidden="true" id="定义注解类和校验逻辑的实现类"></a><a href="#定义注解类和校验逻辑的实现类" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义注解类和校验逻辑的实现类</h3>
<pre><code class="hljs css language-java">@Documented
@Target({ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MaxBytes.MaxBytesValidator.class) // 校验逻辑的实现类
public @interface MaxBytes {
    String message() default "字符串大小不能超过{value}字节"; // 校验失败时的信息

    Class&lt;?&gt;[] groups() default {}; // 分组校验的内容

    Class&lt;? extends Payload&gt;[] payload() default {}; // bean 相关的内容，目前没有用过

    int value() default 0; // 本注解的参数值，表示定义的最大字节大小

    /**
     * 真正实现注解的校验逻辑的类
     * 从 MaxBytes 参数中可以获取注解的初始化的值，例如最大字节大小
     * String 表示被这个注解声明的字段或者参数类型
     */
    class MaxBytesValidator implements ConstraintValidator&lt;MaxBytes, String&gt; {
        private int max;

        @Override
        public void initialize(MaxBytes constraintAnnotation) {
            max = constraintAnnotation.value();
        }

        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            if (value == null) {
                return true;
            }
            return value.getBytes().length &lt;= max;
        }
    }
}
</code></pre>
<p>以上代码有这些细节：</p>
<ul>
<li><p><code>@Constraint(validatedBy = MaxBytes.MaxBytesValidator.class)</code> 表示注解的校验逻辑是由 <code>MaxBytes.MaxBytesValidator.class</code> 来实现的</p>
<ul>
<li>Java 的注解实际上只是个标记，并不具备任何的影响，必须要有其它的代码逻辑来处理注解内容，所以我们除了定义校验注解外，还需要有验证的逻辑的实现类</li>
</ul></li>
<li><p><code>@Target({ElementType.PARAMETER, ElementType.FIELD})</code> 表示这个注解可以声明在方法参数和字段上</p></li>
<li><p>注解的代码</p>
<pre><code class="hljs css language-java">String message() default "字符串大小不能超过{value}字节"; // 校验失败时的信息

Class&lt;?&gt;[] groups() default {}; // 分组校验的内容

Class&lt;? extends Payload&gt;[] payload() default {}; // bean 相关的内容，目前没有用过

int value() default 0; // 本注解的参数值，表示定义的最大字节大小
</code></pre>
<ul>
<li>前三个属性都是校验注解应该要有的</li>
<li><code>字符串大小不能超过{value}字节</code> 这里引用了注解内部的 <code>value()</code> 方法的值</li>
</ul></li>
<li><p><code>class MaxBytesValidator implements ConstraintValidator&lt;MaxBytes, String&gt;</code> 校验逻辑实现类必须实现这个接口</p></li>
<li><p><code>ConstraintValidator&lt;MaxBytes, String&gt;</code></p>
<ul>
<li>第一个泛型表示初始化参数可以使用什么注解的值，这里就是 MaxBytes  注解，这样就可以从 MaxBytes 注解的 value 方法中获取到最大字节数</li>
<li>第二个泛型表示被校验的是什么类型，我们只想校验 String 类型，所以就使用 String 这个泛型。这样 <code>isValid</code> 方法接收的参数类型也是 String，这个 String 就表示我们当前正在校验的内容</li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="将注解声明在字段上"></a><a href="#将注解声明在字段上" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将注解声明在字段上</h3>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringDTO</span> </span>{
    <span class="hljs-meta">@MaxBytes</span>(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">private</span> String str;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="进行校验"></a><a href="#进行校验" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进行校验</h3>
<pre><code class="hljs css language-java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">(@Validated StringDTO stringDTO)</span> </span>{
  <span class="hljs-keyword">return</span> stringDTO;
}
</code></pre>
<pre><code class="hljs"><span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=12345
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：{<span class="hljs-string">"str"</span>:<span class="hljs-string">"12345"</span>}

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=123456
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：错误

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=中12
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：{<span class="hljs-string">"str"</span>:<span class="hljs-string">"中12"</span>}

<span class="hljs-builtin-name">GET</span> localhost:8080/hello?<span class="hljs-attribute">str</span>=中123
My-Header: xxx
cookie: <span class="hljs-attribute">abc</span>=jkl
结果：错误
</code></pre>
<blockquote>
<p>可以看到，这里准确的按照字节数进行了校验</p>
<p>这里的中文字符占用了 3 个字节</p>
</blockquote>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 3/12/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#参考">参考</a></li><li><a href="#jsr303">JSR303</a></li><li><a href="#校验注解列表">校验注解列表</a></li><li><a href="#springboot-校验使用方式">springboot 校验使用方式</a><ul class="toc-headings"><li><a href="#简单使用方式">简单使用方式</a></li><li><a href="#校验结果参数">校验结果参数</a></li><li><a href="#分组校验">分组校验</a></li><li><a href="#对非-dto-的单个参数进行校验">对非 DTO 的单个参数进行校验</a></li><li><a href="#valid-注解内部对象嵌套校验">@Valid 注解内部对象嵌套校验</a></li><li><a href="#小技巧-使用-valid-校验内部的-list-参数">小技巧 使用 @Valid 校验内部的 List 参数</a></li></ul></li><li><a href="#自定义校验注解">自定义校验注解</a><ul class="toc-headings"><li><a href="#定义注解类和校验逻辑的实现类">定义注解类和校验逻辑的实现类</a></li><li><a href="#将注解声明在字段上">将注解声明在字段上</a></li><li><a href="#进行校验">进行校验</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>