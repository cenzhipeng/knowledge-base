<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 问题"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## 问题"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Java系列</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JVM系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/JVM系列/JVM内存区域">JVM内存区域</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/对象创建-布局-访问">对象创建-布局-访问</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存溢出实战">内存溢出实战</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存区域回收">内存区域回收</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/四大引用">四大引用</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/垃圾回收算法">垃圾回收算法</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/HotSpot回收算法细节">HotSpot回收算法细节</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Java系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/java系列/java注解">java注解</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot请求参数绑定">springboot请求参数绑定</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot请求参数校验框架">springboot请求参数校验框架</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/YAML语法">YAML语法</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/动态代理">动态代理</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/classpath和java命令">classpath和java命令</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot-aop编程">springboot-aop编程</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot统一异常处理">springboot统一异常处理</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot数据库和事务">springboot数据库和事务</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot拦截器">springboot拦截器</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot中的web配置">springboot中的web配置</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/docker的简单开发">docker的简单开发</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot自动配置">springboot自动配置</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/数据库的隔离级别">数据库的隔离级别</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/springboot监控">springboot监控</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/java类加载">java类加载</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/java-agent的相关内容">java-agent的相关内容</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/java系列/类加载器详解">类加载器详解</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/java的SecurityManager">java的SecurityManager</a></li><li class="navListItem"><a class="navItem" href="/docs/java系列/maven学习">maven学习</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/块级作用域">块级作用域</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/字符串和正则表达式">字符串和正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/对象">对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Symbol">Symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Set和Map">Set和Map</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/迭代器和生成器">迭代器和生成器</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/类">类</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/数组">数组</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Promise">Promise</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/java系列/19.类加载器详解.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="问题"></a><a href="#问题" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题</h2>
<ul>
<li><code>Class.getCLassLoader()</code> 获取到的类加载器是什么时候绑定在一起的，有什么语义</li>
<li>我们使用 <code>SomeClass a = new SomeClass()</code> 的时候，<code>SomeClass</code> 这个类是被什么类加载器加载的</li>
<li>两个不同的类加载器加载同一个类，是否会初始化两次</li>
<li>Class.forName()  和 classLoader.loadClass() 的区别</li>
<li>默认的线程上下文类加载器是什么</li>
<li>线程上下文类加载器有什么作用</li>
<li>怎么自定义类加载器</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="说明"></a><a href="#说明" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>说明</h2>
<p>本文的源码均来自于我的 Mac 上安装的 <code>adoptopenjdk-8.jdk</code> ，非 Oracle JDK，因此部分细节有可能与 Oracle JDK 8 有所不同，但是应该基本上来说都是一致的。</p>
<p>运行代码时，如果没有明确说明，那么均是使用了 IDEA 提供的 springboot 2.x 模板运行的，主要是为了方便。没有明确说明的时候，都是使用 IDE 的运行按钮去运行的代码，而不是打成 springboot 的 fat jar 运行的。</p>
<p>本文不是很权威，仅仅是说下我个人的理解，因为一直对类加载器这一块儿模模糊糊的，最近正好有时间看这一块儿的内容，决定好好记录一下自己的研究过程和研究成果。</p>
<h2><a class="anchor" aria-hidden="true" id="参考"></a><a href="#参考" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考</h2>
<ul>
<li><a href="https://liuzhengyang.github.io/2016/09/28/classloader/">classLoader使用与原理分析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html">深入探讨 java 类加载器</a></li>
<li><a href="https://www.cnblogs.com/z00377750/p/9175549.html">深度分析 java 的 ClassLoader 机制</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="bootstrapclassloader"></a><a href="#bootstrapclassloader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BootstrapClassLoader</h2>
<p>这个类加载器实际上并不存在于 Java 中，它是由 C++ 编写的 JVM 实现的一部分，它的主要作用就是加载 JDK 的核心类库，以 <code>java.*</code> 开头的那些类（可能应该还有一些 sun 开头的类）。</p>
<p>当我们启动 JVM 的时候（视作一个用 C++ 写的普通的进程），BootstrapClassLoader（存在于 C++ 进程中）就会去加载 JDK 的核心类库，以前我们要配置 CLASSPATH 环境变量应该也是为了去告诉它去哪里加载核心类库所在的 jar 包。现在来说其实是不需要配置 CLASSPATH，JVM 会自动去找到核心类库的 jar 包路径（rt.jar），其实我猜测应该也就是相对于 java 命令本身所在的路径吧（../lib/rt.jar）或者是相对于 $JAVA_HOME 的路径</p>
<blockquote>
<p>在我安装的 <code>adoptopenjdk-8.jdk</code> 中，实际上不存在 $JAVA_HOME/lib/rt.jar，只有 $JAVA_HOME/src.zip，BootstrapClassLoader 加载的是这个 zip 包里的核心类库。（jar包其实就是zip格式）</p>
<p>可以使用 -Xbootclasspath 来改变它加载的路径，具体看我前面的文章 <code>classpath和java命令</code></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="sunmisclauncher"></a><a href="#sunmisclauncher" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sun.misc.Launcher</h2>
<p>一直传说的类加载器的三层模型：BootstrapClassLoader ---&gt; ExtClassLoader ---&gt; AppClassLoader，其实后面 2 个 classLoader 都是 Launcher 的静态内部类。</p>
<p>首先看下 Launcher 的关键逻辑：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>{
        <span class="hljs-comment">// 关键逻辑，这里去调用构造函数构造一个实例了</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Create the extension class loader</span>
        ClassLoader extcl;
        <span class="hljs-keyword">try</span> {
            extcl = ExtClassLoader.getExtClassLoader();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(
                <span class="hljs-string">"Could not create extension class loader"</span>, e);
        }

        <span class="hljs-comment">// Now create the class loader to use to launch the application</span>
        <span class="hljs-keyword">try</span> {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(
                <span class="hljs-string">"Could not create application class loader"</span>, e);
        }

        <span class="hljs-comment">// Also set the context class loader for the primordial thread.</span>
        Thread.currentThread().setContextClassLoader(loader);

        <span class="hljs-comment">// Finally, install a security manager if requested</span>
        String s = System.getProperty(<span class="hljs-string">"java.security.manager"</span>);
        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// init FileSystem machinery before SecurityManager installation</span>
            sun.nio.fs.DefaultFileSystemProvider.create();

            SecurityManager sm = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(s) || <span class="hljs-string">"default"</span>.equals(s)) {
                sm = <span class="hljs-keyword">new</span> java.lang.SecurityManager();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">try</span> {
                    sm = (SecurityManager)loader.loadClass(s).newInstance();
                } <span class="hljs-keyword">catch</span> (IllegalAccessException e) {
                } <span class="hljs-keyword">catch</span> (InstantiationException e) {
                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                } <span class="hljs-keyword">catch</span> (ClassCastException e) {
                }
            }
            <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
                System.setSecurityManager(sm);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(
                    <span class="hljs-string">"Could not create SecurityManager: "</span> + s);
            }
        }
    }
}
</code></pre>
<ul>
<li><p><code>private static Launcher launcher = new Launcher();</code> 初始化的逻辑：</p>
<ul>
<li>因为 Launcher 属于核心类库，因此它被 BootstrapClassLoader 加载后执行了初始化，因此这里就调用构造方法构造了 Launcher 实例</li>
</ul></li>
<li><p><code>public Launcher()</code> 构造方法的逻辑：</p>
<ul>
<li><p>使用 <code>ExtClassLoader.getExtClassLoader()</code> 构造 ExtClassLoader 实例</p></li>
<li><p>使用 <code>loader = AppClassLoader.getAppClassLoader(extcl);</code> 构造 AppClassLoader 实例，实际上也就是 AppClassLoader 内部持有 ExtClassLoader 实例</p></li>
<li><p><code>Thread.currentThread().setContextClassLoader(loader);</code></p>
<ul>
<li>将 AppClassLoader 设置为线程上下文类加载器</li>
</ul></li>
<li><p>使用 <code>java.security.manager</code> 定义的 SecurityManager 类名，使用 AppClassLoader 加载后作为系统的 SecurityManager，如果没有定义，就使用 <code>java.lang.SecurityManager</code>（这一块儿以后再研究）</p></li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="总结"></a><a href="#总结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<ul>
<li>ExtClassLoader 和 AppClassLoader 都是 Launcher 的静态内部类</li>
<li><strong>Launcher 被 BootstrapClassLoader 加载初始化后，先后构造了 ExtClassLoader 和 AppClassLoader 实例，然后将 AppClassLoader 设置为线程的上下文类加载器，这就是 Launcher 的主要逻辑</strong></li>
<li>AppClassLoader 被 Launcher 持有作为它给出的 ClassLoader</li>
<li>AppClassLoader 内部持有 ExtClassLoader 作为上层的 ClassLoader</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="extclassloader"></a><a href="#extclassloader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ExtClassLoader</h2>
<p>ExtClassLoader 是用来加载以 <code>javax.*</code> 开头的那些 java 扩展类库，这些类库的 jar 包存在于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下，说白了这个 ExtClassLoader 就是专门去加载这个路径下的 jar 包的，我们把自己的 jar 包扔到这个路径下面也会被它加载，可以使用 java 系统属性：<code>java.ext.dirs</code> 来改变它加载的路径</p>
<h3><a class="anchor" aria-hidden="true" id="初始化逻辑"></a><a href="#初始化逻辑" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>初始化逻辑</h3>
<pre><code class="hljs css language-java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLClassLoader</span> </span>{
    <span class="hljs-keyword">static</span> {
        ClassLoader.registerAsParallelCapable();
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> ExtClassLoader instance = <span class="hljs-keyword">null</span>;
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExtClassLoader <span class="hljs-title">getExtClassLoader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException
        </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">synchronized</span>(ExtClassLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>{
                    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                        instance = createExtClassLoader();
                    }
                }
            }
            <span class="hljs-keyword">return</span> instance;
        }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExtClassLoader <span class="hljs-title">createExtClassLoader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Prior implementations of this doPrivileged() block supplied</span>
            <span class="hljs-comment">// aa synthesized ACC via a call to the private method</span>
            <span class="hljs-comment">// ExtClassLoader.getContext().</span>

            <span class="hljs-keyword">return</span> AccessController.doPrivileged(
                <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() {
                    <span class="hljs-function"><span class="hljs-keyword">public</span> ExtClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
                        <span class="hljs-keyword">final</span> File[] dirs = getExtDirs();
                        <span class="hljs-keyword">int</span> len = dirs.length;
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                            MetaIndex.registerDirectory(dirs[i]);
                        }
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExtClassLoader(dirs);
                    }
                });
        } <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException e) {
            <span class="hljs-keyword">throw</span> (IOException) e.getException();
        }
    }
}
</code></pre>
<ul>
<li><p>被 Launcher 构造之前进行初始化</p></li>
<li><p>初始化 <code>ClassLoader.registerAsParallelCapable();</code> 的逻辑：</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@CallerSensitive</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">registerAsParallelCapable</span><span class="hljs-params">()</span> </span>{
    Class&lt;? extends ClassLoader&gt; callerClass =
        Reflection.getCallerClass().asSubclass(ClassLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-keyword">return</span> ParallelLoaders.register(callerClass);
}
</code></pre>
<ul>
<li>使用反射获取到调用这个方法的类，也就是 ExtClassLoader</li>
<li>将自己注册为可并行的类加载器</li>
</ul></li>
</ul>
<blockquote>
<p>初始化主要是注册自己为可并行的类加载器，这种使用反射 Reflection.getCallerClass() 的模式就很有用，注册了之后，ClassLoader 就知道：这个 ClassLoader 可以并行加载，也就是说它的 loadClass 方法可以安全地被多个线程调用去加载类</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="getextclassloader-方法"></a><a href="#getextclassloader-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getExtClassLoader 方法</h3>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExtClassLoader <span class="hljs-title">getExtClassLoader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException
</span>{
    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span>(ExtClassLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                instance = createExtClassLoader();
            }
        }
    }
    <span class="hljs-keyword">return</span> instance;
}
</code></pre>
<ul>
<li>双重判空来确保单例</li>
<li>使用 createExtClassLoader 方法构造出单例对象作为自己的静态字段</li>
</ul>
<blockquote>
<p>没啥太多说的，主要是确保只有一个单例，最终逻辑还是在 createExtClassLoader 方法</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="createextclassloader-方法"></a><a href="#createextclassloader-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>createExtClassLoader 方法</h3>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExtClassLoader <span class="hljs-title">createExtClassLoader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Prior implementations of this doPrivileged() block supplied</span>
        <span class="hljs-comment">// aa synthesized ACC via a call to the private method</span>
        <span class="hljs-comment">// ExtClassLoader.getContext().</span>

        <span class="hljs-keyword">return</span> AccessController.doPrivileged(
            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() {
                <span class="hljs-function"><span class="hljs-keyword">public</span> ExtClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{
                    <span class="hljs-keyword">final</span> File[] dirs = getExtDirs();
                    <span class="hljs-keyword">int</span> len = dirs.length;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                        MetaIndex.registerDirectory(dirs[i]);
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExtClassLoader(dirs);
                }
            });
    } <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException e) {
        <span class="hljs-keyword">throw</span> (IOException) e.getException();
    }
}
</code></pre>
<ul>
<li>使用 getExtDirs 里获取到的文件路径，最后构造了一个 ExtClassLoader 实例</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="appclassloader"></a><a href="#appclassloader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AppClassLoader</h3>
<p>AppClassLoader 是用来加载我们自行传入的应用程序所包含的类的，我们传入的 classpath 最终就会被 AppClassLoader 去加载，通过 <code>java -cp dir1:dir2:dir3:aaa.jar:bbb.jar</code> 传入多个 classpath</p>
<h3><a class="anchor" aria-hidden="true" id="初始化逻辑-1"></a><a href="#初始化逻辑-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>初始化逻辑</h3>
<pre><code class="hljs css language-java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLClassLoader</span> </span>{
        <span class="hljs-keyword">static</span> {
            ClassLoader.registerAsParallelCapable();
        }
}
</code></pre>
<ul>
<li>被 Launcher 构造之前进行初始化</li>
<li><code>ClassLoader.registerAsParallelCapable();</code> 将自己注册为可并行的类加载器</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getappclassloader-方法"></a><a href="#getappclassloader-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getAppClassLoader 方法</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader extcl)</span>
            <span class="hljs-keyword">throws</span> IOException
        </span>{
            <span class="hljs-keyword">final</span> String s = System.getProperty(<span class="hljs-string">"java.class.path"</span>);
            <span class="hljs-keyword">final</span> File[] path = (s == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : getClassPath(s);

            <span class="hljs-keyword">return</span> AccessController.doPrivileged(
                <span class="hljs-keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() {
                    <span class="hljs-function"><span class="hljs-keyword">public</span> AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                    URL[] urls =
                        (s == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : pathToURLs(path);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AppClassLoader(urls, extcl);
                }
            });
        }

        <span class="hljs-keyword">final</span> URLClassPath ucp;

        <span class="hljs-comment">/*
         * Creates a new AppClassLoader
         */</span>
        AppClassLoader(URL[] urls, ClassLoader parent) {
            <span class="hljs-keyword">super</span>(urls, parent, factory);
            ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="hljs-keyword">this</span>);
            ucp.initLookupCache(<span class="hljs-keyword">this</span>);
        }
</code></pre>
<ul>
<li>Launcher 使用 getAppClassLoader 获取一个 AppClassLoader 实例，传入的是 ExtClassLoader</li>
<li>我们通过 <code>java -cp</code> 传递的 classpath，在 java 程序中通过 <code>System.getProperty(&quot;java.class.path&quot;);</code> 访问到</li>
<li>将 classpath 转换成 url 的集合，缓存到它继承的 URLClassPath 中去</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="classloader-类源码分析"></a><a href="#classloader-类源码分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ClassLoader 类源码分析</h2>
<h3><a class="anchor" aria-hidden="true" id="说明-1"></a><a href="#说明-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>说明</h3>
<p>源码是 mac 下的 adoptopenjdk-8，主要是进行 ClassLoader 的一些关键逻辑的分析，一些细枝末节和一些跟安全性相关的内容没有仔细去看和了解。主要是着眼于 ClassLoader 加载类的流程，以及它加载的一些机制。</p>
<h3><a class="anchor" aria-hidden="true" id="静态变量"></a><a href="#静态变量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态变量</h3>
<ul>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// The class loader for the system</span>
<span class="hljs-comment">// @GuardedBy("ClassLoader.class")</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClassLoader scl;
</code></pre>
<ul>
<li>系统类加载器，也就是 AppClassLoader</li>
</ul></li>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// Set to true once the system class loader has been set</span>
<span class="hljs-comment">// @GuardedBy("ClassLoader.class")</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> sclSet;
</code></pre>
<ul>
<li>表示系统类加载器是否已经设置了，一旦 AppClassLoader 被设置给 scl，这个值就是 true</li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="总结-1"></a><a href="#总结-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>
<p>也就是说，ClassLoader 的静态变量也会持有一个系统类加载器，也就是 AppClassLoader</p>
<h3><a class="anchor" aria-hidden="true" id="实例变量"></a><a href="#实例变量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例变量</h3>
<ul>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// The parent class loader for delegation</span>
<span class="hljs-comment">// Note: VM hardcoded the offset of this field, thus all new fields</span>
<span class="hljs-comment">// must be added *after* it.</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;
</code></pre>
<ul>
<li>每个 ClassLoader 的实现类，都持有一个 parent 的 ClassLoader，因此 ClassLoader 的层次结构类似于一棵树，任何一个 ClassLoader 最后都通过 parent 逐步向上到达树根：null（BootstrapClassLoader）</li>
</ul></li>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// Maps class name to the corresponding lock object when the current</span>
<span class="hljs-comment">// class loader is parallel capable.</span>
<span class="hljs-comment">// Note: VM also uses this field to decide if the current class loader</span>
<span class="hljs-comment">// is parallel capable and the appropriate lock object for class loading.</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
</code></pre>
<ul>
<li>这个 parallelLockMap 只有注册了并行加载能力的 ClassLoader 才有，没有注册并行加载能力的 ClassLoader，这个字段的值将会是 null</li>
<li>ClassLoader 使用这个字段来判断：定义的具体的 ClassLoader 是否具有并行加载能力（loadClass 方法是否能够被不同线程同时访问）。</li>
<li>如果没有并行加载能力，loadClass 将会是一个同步方法，锁对象就是当前的 ClassLoader 实例。如果有并行加载能力，将会从这个 map 里获取到锁对象（map是类名到锁对象的映射），如果没有锁对象的话（表示当前这个类没有其他线程在加载），就新生成一个 Object 作为锁对象，然后在加载这个特定类的时候使用这个锁对象加锁</li>
<li>也就是说：
<ul>
<li>默认加载所有的类都使用当前的 ClassLoader 实例加锁</li>
<li>注册了并行加载后，仅在加载 A 类时使用 A 类对应的某个特定锁对象 lockA，加载 B 类时使用 B 类对应的某个锁对象 lockB，这样就大大减小了锁的粒度</li>
</ul></li>
</ul></li>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// The classes loaded by this class loader. The only purpose of this table</span>
<span class="hljs-comment">// is to keep the classes from being GC'ed until the loader is GC'ed.</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> Vector&lt;&gt;();
</code></pre>
<ul>
<li>每个 ClassLoader 都持有它自己加载过了的所有的类，唯一的目的就是保持一点：这些被加载后生成的 Class 对象不会被 GC 回收掉，因为：这个数组持有所有自己加载了的 Class 对象的强引用</li>
<li>findLoadedClass(name)，也就是查找当前 ClassLoader 是否已经加载过某个类的方法，并不是依靠这个 classes 来实现的，真正实现这个逻辑的在 native 方法中，也就是 JVM 实现里。因为很显然我们这里只能得到类的名称，并没有办法直接与 Vector&lt;Class&lt;?&gt;&gt; 去查找然后判断自己是否加载过这个类（当然我们也可以自己重写这种逻辑）</li>
</ul></li>
<li><pre><code class="hljs css language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProtectionDomain defaultDomain =
    <span class="hljs-keyword">new</span> ProtectionDomain(<span class="hljs-keyword">new</span> CodeSource(<span class="hljs-keyword">null</span>, (Certificate[]) <span class="hljs-keyword">null</span>),
                         <span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);
</code></pre>
<ul>
<li>主要关注点在：构造这个 ProtectionDomain 的时候，把 this 指针，也就是当前 ClassLoader 加入进去了。</li>
<li>当真正让 JVM 去加载类的时候，其实是调用了 defineClass 方法，最终将这个 ProtectionDomain 传递给了这个 native 方法。因此 native 构造出 Class 对象的时候，是可以通过 ProtectionDomain 获取到当前 ClassLoader 对象实例的，所以当我们调用 someClass.getClassLoader() 的时候可以获取到它的类加载器，这个类加载器就是通过 ProtectionDomain 加入进去的</li>
</ul></li>
<li><pre><code class="hljs css language-java"><span class="hljs-comment">// The packages defined in this class loader.  Each package name is mapped</span>
<span class="hljs-comment">// to its corresponding Package object.</span>
<span class="hljs-comment">// @GuardedBy("itself")</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, Package&gt; packages = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
</code></pre>
<ul>
<li>表示这个 ClassLoader 加载过了的所有的包，map的内容是包名到 Package 这个存储了包的定义的映射</li>
<li>我们可以调用 someClassLoader 来获得某个包的定义，如果这个包没有被这个 ClassLoader 加载过，默认的 ClassLoader 实现会将这个包名的查询也转交给持有的上层的 ClassLoader 去查询</li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="总结-2"></a><a href="#总结-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>
<ul>
<li>每个 ClassLoader 都持有一个 parent 对象，表示它的上层的 ClassLoader，AppClassLoader 上层是 ExtClassLoader，ExtClassLoader 上层是 null（BootstrapClassLoader）</li>
<li>由于这种持有的关系，所以 ClassLoader 是一种树状的关系，最上层的是 BootstrapClassLoader</li>
<li>一个 ClassLoader 的实现类默认是不能并行处理的，在 loadClass 方法中会对当前 ClassLoader 实例加锁。需要在静态初始化代码块中调用：<code>ClassLoader.registerAsParallelCapable();</code> 将自己注册为可并行的类加载器。此时这个 ClassLoader 只有在加载同一个类的时候会进行线程同步，加载不同的类是可以并行的。</li>
<li>每个 ClassLoader 实例构造出来的每个 Class 实例，都默认绑定了这个 ClassLoader 实例，通过 Class 实例的 getClassLoader 方法可以获取到真正加载它的 ClassLoader 实例（真正 define 这个 Class 的 ClassLoader）</li>
<li>由于委托模式的存在，<code>Class a = classLoaderA.load(&quot;xxxName&quot;)</code>，最终 a 代表的 Class 不一定是 classLoaderA 加载的，可能是它的 parent 加载的，也就是说 <code>a.getClassLoader()</code> 不一定是 classLoaderA，可能是 <code>classLoaderA.getParent()</code>，或者是 <code>classLoaderA.getParent().getParent()</code></li>
<li>每个 ClassLoader 实例都保存了它加载过的 package，我们可以传入完整的包名给 ClassLoader 实例，然后获取到这个包名对应的 Package 对象，从而获取包的更多信息</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="静态方法"></a><a href="#静态方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态方法</h3>
<h4><a class="anchor" aria-hidden="true" id="registerasparallelcapable"></a><a href="#registerasparallelcapable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>registerAsParallelCapable</h4>
<pre><code class="hljs css language-java"><span class="hljs-meta">@CallerSensitive</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">registerAsParallelCapable</span><span class="hljs-params">()</span> </span>{
    Class&lt;? extends ClassLoader&gt; callerClass =
        Reflection.getCallerClass().asSubclass(ClassLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-keyword">return</span> ParallelLoaders.register(callerClass);
}
</code></pre>
<ul>
<li>如果一个 ClassLoader 想要实现并行加载，那么在静态初始化的时候，需要调用这个静态方法，将自己注册到并行加载器里面</li>
<li>它的主要逻辑就是使用反射获取调用类：也就是哪个类调用了这个方法（<code>Reflection.getCallerClass(</code>），这个可以值得关注</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getsystemresource"></a><a href="#getsystemresource" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getSystemResource</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> URL <span class="hljs-title">getSystemResource</span><span class="hljs-params">(String name)</span> </span>{
    ClassLoader system = getSystemClassLoader();
    <span class="hljs-keyword">if</span> (system == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> getBootstrapResource(name);
    }
    <span class="hljs-keyword">return</span> system.getResource(name);
}
</code></pre>
<ul>
<li>获取系统类加载器：AppClassLoader</li>
<li>使用 AppClassLoader 实例的 getResource 方法获取资源 URL</li>
<li>实际上 AppClassLoader 并没有重写 getResource 方法，最后调用的就是 ClassLoader 实例的 getResource 方法</li>
<li>语义是：使用系统类加载器去寻找某个资源，例如 &quot;META-INF/MANIFEST.MF&quot; 就表示找到某个 jar 包下的这个文件，多个 jar 包是可以存在相同的文件的，而这个方法仅仅是找到其中一个，然后就直接返回</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getsystemresources"></a><a href="#getsystemresources" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getSystemResources</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Enumeration&lt;URL&gt; <span class="hljs-title">getSystemResources</span><span class="hljs-params">(String name)</span>
    <span class="hljs-keyword">throws</span> IOException
</span>{
    ClassLoader system = getSystemClassLoader();
    <span class="hljs-keyword">if</span> (system == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> getBootstrapResources(name);
    }
    <span class="hljs-keyword">return</span> system.getResources(name);
}
</code></pre>
<ul>
<li>寻找的逻辑与上面一致，唯一的区别是：将所有找到的资源都返回，返回的是一个枚举，我们可以迭代这个枚举从而遍历所有找到的资源</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getsystemresourceasstream"></a><a href="#getsystemresourceasstream" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getSystemResourceAsStream</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title">getSystemResourceAsStream</span><span class="hljs-params">(String name)</span> </span>{
    URL url = getSystemResource(name);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> url != <span class="hljs-keyword">null</span> ? url.openStream() : <span class="hljs-keyword">null</span>;
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
<ul>
<li>寻找的逻辑与上面一样，唯一的区别是，这里找到的资源返回的是 InputStream，实际上来说仅仅是比上面多了一步，多帮我们调用了一个 <code>url.openStream()</code>，没什么其它好说的</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getsystemclassloader"></a><a href="#getsystemclassloader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getSystemClassLoader</h4>
<pre><code class="hljs css language-java"><span class="hljs-meta">@CallerSensitive</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>{
    initSystemClassLoader();
    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    SecurityManager sm = System.getSecurityManager();
    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
        checkClassLoaderPermission(scl, Reflection.getCallerClass());
    }
    <span class="hljs-keyword">return</span> scl;
}
</code></pre>
<ul>
<li>获取系统类加载器，也就是 AppClassLoader</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="总结-3"></a><a href="#总结-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>
<ul>
<li>具体的 ClassLoader 实现类通过 ClassLoader 的静态方法 registerAsParallelCapable，在将自己注册为可并行加载的类加载器（多线程同时执行这个 ClassLoader 实例的 loadClass 方法）</li>
<li>使用 getSystemResource 和 getSystemResources 方法，我们传入某个资源在某个 jar 包里的完整路径，比如 &quot;META-INF/MANIFEST.MF&quot; 这种，获取到这个资源的 URL
<ul>
<li>这两个方法基本等价于 AppClassLoader 实例的 getResource/getResources 方法</li>
<li>与类加载的委托机制类似，寻找资源的时候也是先让父加载器去寻找，最后才自己寻找</li>
<li>getSystemResource 只找到第一个资源就返回，getSystemResources 则是找到所有资源，然后返回所有 URL 的枚举，我们可以遍历处理</li>
</ul></li>
<li>getSystemResourceAsStream 方法几乎与 getSystemResource 一致，仅仅是多调用了一个 url.openStream()</li>
<li>getSystemClassLoader 获取到系统类加载器 AppClassLoader 实例</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="实例方法"></a><a href="#实例方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例方法</h3>
<h4><a class="anchor" aria-hidden="true" id="构造方法"></a><a href="#构造方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构造方法</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClassLoader</span><span class="hljs-params">(Void unused, ClassLoader parent)</span> </span>{
    <span class="hljs-keyword">this</span>.parent = parent;
    <span class="hljs-keyword">if</span> (ParallelLoaders.isRegistered(<span class="hljs-keyword">this</span>.getClass())) {
        parallelLockMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
        package2certs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
        assertionLock = <span class="hljs-keyword">new</span> Object();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// no finer-grained lock; lock on the classloader instance</span>
        parallelLockMap = <span class="hljs-keyword">null</span>;
        package2certs = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();
        assertionLock = <span class="hljs-keyword">this</span>;
    }
}
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span> </span>{
    <span class="hljs-keyword">this</span>(checkCreateClassLoader(), parent);
}
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">ClassLoader</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());
}
</code></pre>
<ul>
<li>可以看到，前两个构造方法都要传入父类类加载器 parent</li>
<li>第三个构造方法使用 getSystemClassLoader 获取系统类加载器 AppClassLoader 实例</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="loadclass"></a><a href="#loadclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>loadClass</h4>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {
    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);
}

<span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)
    <span class="hljs-keyword">throws</span> ClassNotFoundException
{
    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) {
        <span class="hljs-comment">// First, check if the class has already been loaded</span>
        Class&lt;?&gt; c = findLoadedClass(name);
        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">long</span> t0 = System.nanoTime();
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) {
                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);
                } <span class="hljs-keyword">else</span> {
                    c = findBootstrapClassOrNull(name);
                }
            } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>
                <span class="hljs-comment">// from the non-null parent class loader</span>
            }

            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// If still not found, then invoke findClass in order</span>
                <span class="hljs-comment">// to find the class.</span>
                <span class="hljs-keyword">long</span> t1 = System.nanoTime();
                c = findClass(name);

                <span class="hljs-comment">// this is the defining class loader; record the stats</span>
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        <span class="hljs-keyword">if</span> (resolve) {
            resolveClass(c);
        }
        <span class="hljs-keyword">return</span> c;
    }
}
</code></pre>
<ul>
<li>两个方法只是不同的重载，不传入 resolve 参数的 loadClass 方法表示：加载该类，但是并不解析，解析的工作是后续由 JVM 去完成的（也就是我们并不需要显式调用 <code>loadClass(someClass, true)</code>）</li>
<li>首先调用 <code>findLoadedClass(name)</code> 判断自己是否加载过这个类</li>
<li>然后委托父加载器 parent 去加载该类</li>
<li>如果加载不到，就自己去加载该类，加载的逻辑就在 findClass 方法中，这个方法的语义是：根据类名找到该类并且加载</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="findclass"></a><a href="#findclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>findClass</h4>
<pre><code class="hljs css language-java"><span class="hljs-comment">// ClassLoader.java</span>
<span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);
}

<span class="hljs-comment">// URLClassLoader.java</span>
<span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(<span class="hljs-keyword">final</span> String name)
    <span class="hljs-keyword">throws</span> ClassNotFoundException
{
    <span class="hljs-keyword">final</span> Class&lt;?&gt; result;
    <span class="hljs-keyword">try</span> {
        result = AccessController.doPrivileged(
            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() {
                <span class="hljs-keyword">public</span> Class&lt;?&gt; run() <span class="hljs-keyword">throws</span> ClassNotFoundException {
                    String path = name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>);
                    Resource res = ucp.getResource(path, <span class="hljs-keyword">false</span>);
                    <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) {
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-keyword">return</span> defineClass(name, res);
                        } <span class="hljs-keyword">catch</span> (IOException e) {
                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name, e);
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                    }
                }
            }, acc);
    } <span class="hljs-keyword">catch</span> (java.security.PrivilegedActionException pae) {
        <span class="hljs-keyword">throw</span> (ClassNotFoundException) pae.getException();
    }
    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<ul>
<li><p>ClassLoader 的 findClass 方法直接抛出异常，它的语义是让具体的 ClassLoader 一定要重写这个方法，也就是说，将 &quot;根据全类名找到某个类并且加载&quot; 这个动作交给了子类去实现，赋予了子类重写方法的权限。因此也就给我们自定义类加载器留下了一个很重要的口子</p></li>
<li><p>AppClassLoader 和 ExtClassLoader 都继承自 URLClassLoader，它们俩并未再次重写 findClass 这个方法，而是直接使用的 URLClassLoader 的 findClass 方法</p></li>
<li><pre><code class="hljs css language-java">String path = name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>);
Resource res = ucp.getResource(path, <span class="hljs-keyword">false</span>);
</code></pre>
<ul>
<li>核心逻辑就是将类名的点号替换为目录的分隔符，然后加上类的扩展名 <code>class</code> ，然后使用 <code>ucp.getResource</code> 去找到这个类文件
<ul>
<li>实际上 AppClassLoader 的 getResource 的核心逻辑就是 <code>ucp.getResource</code>，<code>ucp</code> 对象里保存了 AppClassLoader 应该加载的 classpath，从这些 classpath 里去寻找资源文件</li>
</ul></li>
</ul></li>
<li><p><code>return defineClass(name, res);</code>，真正加载了类并且返回 Class 对象的就是这个 defineClass 方法</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">long</span> t0 = System.nanoTime();
    <span class="hljs-keyword">int</span> i = name.lastIndexOf(<span class="hljs-string">'.'</span>);
    URL url = res.getCodeSourceURL();
    <span class="hljs-keyword">if</span> (i != -<span class="hljs-number">1</span>) {
        String pkgname = name.substring(<span class="hljs-number">0</span>, i);
        <span class="hljs-comment">// Check if package already loaded.</span>
        Manifest man = res.getManifest();
        definePackageInternal(pkgname, man, url);
    }
    <span class="hljs-comment">// Now read the class bytes and define the class</span>
    java.nio.ByteBuffer bb = res.getByteBuffer();
    <span class="hljs-keyword">if</span> (bb != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Use (direct) ByteBuffer:</span>
        CodeSigner[] signers = res.getCodeSigners();
        CodeSource cs = <span class="hljs-keyword">new</span> CodeSource(url, signers);
        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);
        <span class="hljs-keyword">return</span> defineClass(name, bb, cs);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">byte</span>[] b = res.getBytes();
        <span class="hljs-comment">// must read certificates AFTER reading bytes.</span>
        CodeSigner[] signers = res.getCodeSigners();
        CodeSource cs = <span class="hljs-keyword">new</span> CodeSource(url, signers);
        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);
        <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length, cs);
    }
}
</code></pre>
<ul>
<li><p>这里的逻辑主要是根据 Resource 然后去读取这个类的字节码，存放在数组中，最终调用了 ClassLoader 的方法</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len,
                                     ProtectionDomain protectionDomain)
    <span class="hljs-keyword">throws</span> ClassFormatError
{
    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    <span class="hljs-keyword">return</span> c;
}
</code></pre></li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getresource"></a><a href="#getresource" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getResource</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> URL <span class="hljs-title">getResource</span><span class="hljs-params">(String name)</span> </span>{
    URL url;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) {
        url = parent.getResource(name);
    } <span class="hljs-keyword">else</span> {
        url = getBootstrapResource(name);
    }
    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
        url = findResource(name);
    }
    <span class="hljs-keyword">return</span> url;
}
</code></pre>
<ul>
<li>首先调用持有的父类加载器的 getResource 方法
<ul>
<li>对于 ExtClassLoader 和 AppClassLoader 来说，它们俩都没有重写这个方法</li>
<li>因此它们最终都走到了 else 分支，调用 getBootstrapResource 方法了</li>
<li>也就是说加载资源也遵循父类优先的模式
<ul>
<li>首先让 parent 去加载资源</li>
<li>parent 加载不到的话就自己去加载资源</li>
</ul></li>
<li>如果同一个资源有多个的话，最先被找到的那个资源被返回，例如我们可能加载了多个 jar，多个 jar 可能有多个相同的资源，比如 jar 包里都有某个清单文件，此时只有第一个被找到的才返回</li>
<li>寻找的模式是 jar 包里的文件，例如说我们想要找到 java.lang.String 这个类的类文件，可以使用 <code>ClassLoader.getSystemClassLoader().getResource(&quot;java/lang/String.class&quot;)</code></li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="getresources"></a><a href="#getresources" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getResources</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;URL&gt; <span class="hljs-title">getResources</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="hljs-keyword">new</span> Enumeration&lt;?&gt;[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) {
        tmp[<span class="hljs-number">0</span>] = parent.getResources(name);
    } <span class="hljs-keyword">else</span> {
        tmp[<span class="hljs-number">0</span>] = getBootstrapResources(name);
    }
    tmp[<span class="hljs-number">1</span>] = findResources(name);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);
}
</code></pre>
<p>与上面的类似，只不过返回的是这个 ClassLoader 实例的所有找到的资源，上面 getResource 仅仅找到第一个就直接返回</p>
<h4><a class="anchor" aria-hidden="true" id="getresourceasstream"></a><a href="#getresourceasstream" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getResourceAsStream</h4>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getResourceAsStream</span><span class="hljs-params">(String name)</span> </span>{
    URL url = getResource(name);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> url != <span class="hljs-keyword">null</span> ? url.openStream() : <span class="hljs-keyword">null</span>;
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
<p>与 getResource 基本一致，仅仅是帮我们调用了 <code>url.openStream()</code></p>
<h4><a class="anchor" aria-hidden="true" id="getparent"></a><a href="#getparent" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>getParent</h4>
<pre><code class="hljs css language-java"><span class="hljs-meta">@CallerSensitive</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title">getParent</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    SecurityManager sm = System.getSecurityManager();
    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Check access to the parent class loader</span>
        <span class="hljs-comment">// If the caller's class loader is same as this class loader,</span>
        <span class="hljs-comment">// permission check is performed.</span>
        checkClassLoaderPermission(parent, Reflection.getCallerClass());
    }
    <span class="hljs-keyword">return</span> parent;
}
</code></pre>
<p>获取到父加载器，这里还会根据当前调用这个获取父加载器方法的类，检查这个类是否有权限去获取</p>
<h3><a class="anchor" aria-hidden="true" id="总结-4"></a><a href="#总结-4" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<ul>
<li><p>ClassLoader 构造方法决定了，每个类必有一个 parent 父加载器，如果实现的子类 ClassLoader 没有传入 parent 父加载器的话，默认是系统类加载器 AppClassLoader 实例</p></li>
<li><p>loadClass 方法默认不对类进行解析工作（解析由 JVM 自己完成）</p></li>
<li><p>loadClass 方法的默认行为是双亲委托，即：一个 ClassLoader 实例 loadClass 的时候，首先交给它的 parent 去 loadClass，如果 parent 加载失败了，自己才去尝试加载这个类，加载的逻辑在 findClass 方法中。这样的双亲委托保证我们使用核心类库的时候使用的是相同的版本（后面详细说明）</p></li>
<li><p>findClass 是我们定义一个 ClassLoader 实现类的最重要的逻辑，它的语义是</p>
<ul>
<li><p>根据一个类名，获取到类的二进制字节数组</p></li>
<li><p>最终要负责调用</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len,
                                     ProtectionDomain protectionDomain)
</code></pre>
<p>就实现了加载类的功能</p></li>
</ul></li>
<li><p>getResource 系列的方法，默认也遵循双亲委托的模式，先由 parent 去找到资源，最后再自己去找</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="类如何与类加载器绑定在一起的"></a><a href="#类如何与类加载器绑定在一起的" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类如何与类加载器绑定在一起的</h2>
<pre><code class="hljs css language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span></span>{
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProtectionDomain defaultDomain =
        <span class="hljs-keyword">new</span> ProtectionDomain(<span class="hljs-keyword">new</span> CodeSource(<span class="hljs-keyword">null</span>, (Certificate[]) <span class="hljs-keyword">null</span>),
                             <span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);
    
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len,
                                         ProtectionDomain protectionDomain)
        <span class="hljs-keyword">throws</span> ClassFormatError
    {
        protectionDomain = preDefineClass(name, protectionDomain);
        String source = defineClassSourceLocation(protectionDomain);
        Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);
        postDefineClass(c, protectionDomain);
        <span class="hljs-keyword">return</span> c;
    }
}

</code></pre>
<ul>
<li>任何 ClassLoader 的实现类，都有来自于基类 ClassLoader 的 ProtectionDomain 属性</li>
<li>在这个属性中传入了当前实现类对象的指针 <code>new ProtectionDomain(new CodeSource(null, (Certificate[]) null), null, this, null);</code>（倒数第二个 this 代表实现类）</li>
<li>define class 的时候，将 defaultDomain 传给了 native 方法，因此通过这个 defaultDomain 与加载这个类的 classloader 绑定在了一起</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="引用某个类的时候，使用的是什么-classloader"></a><a href="#引用某个类的时候，使用的是什么-classloader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引用某个类的时候，使用的是什么 ClassLoader</h2>
<h3><a class="anchor" aria-hidden="true" id="引用某个类的方式"></a><a href="#引用某个类的方式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引用某个类的方式</h3>
<p>我们有多种方式引用某个类，例如：</p>
<ul>
<li><code>A a = new A();</code> 直接引用</li>
<li><code>Class.forName()</code></li>
<li><code>someClassLoader.loadClass(className)</code></li>
<li><code>A.class</code></li>
</ul>
<p>一个类完整的命名空间其实是：加载这个类的 ClassLoader 实例 + 完整类名</p>
<p>我们在引用一个类的时候其实都隐含了一个 ClassLoader 实例，下面分析这些引用方式用到的 ClassLoader</p>
<h3><a class="anchor" aria-hidden="true" id="直接引用"></a><a href="#直接引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>直接引用</h3>
<p>当我们在 A 类中引用 B 类的时候，默认将使用 A 类的类加载器去加载 B 类（但是由于委托模式的存在，最终真正加载 B 类的不一定是 A 类的类加载器）</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemoApplication</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>{
        System.out.println(<span class="hljs-string">"系统启动"</span>);
        MyClassLoader myClassLoader = <span class="hljs-keyword">new</span> MyClassLoader(
                <span class="hljs-string">"/Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo"</span>);
        Class&lt;?&gt; a = myClassLoader.loadClass(<span class="hljs-string">"Main"</span>);
        Method mainMethod = a.getMethod(<span class="hljs-string">"main"</span>,String[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        mainMethod.invoke(<span class="hljs-keyword">null</span>, (Object) <span class="hljs-keyword">null</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>{
        <span class="hljs-keyword">private</span> Path startPath;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String startPath)</span></span>{
            <span class="hljs-comment">// MyClassLoader 实例的 parent 加载器将是系统类加载器 AppClassLoader</span>
            <span class="hljs-keyword">super</span>();
            <span class="hljs-keyword">this</span>.startPath = Paths.get(startPath);
        }
        <span class="hljs-meta">@SneakyThrows</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {
            Path classPath = startPath.resolve(name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>));
            <span class="hljs-keyword">byte</span>[] bytes = Files.readAllBytes(classPath);
            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);
        }
    }
}


<span class="hljs-comment">// /Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/Main.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        A a = <span class="hljs-keyword">new</span> A();
        a.hello();
        System.out.println(a.getClass().getClassLoader().getClass().getName());
    }
}

<span class="hljs-comment">// /Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/A.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"hello, ClassLoader"</span>);
    }
}

</code></pre>
<ul>
<li>JavaDemoApplication 是我们的主类，并且定义了一个静态内部类 MyClassLoader</li>
<li>MyClassLoader 的 parent 类加载器是系统类加载器 AppClassLoader</li>
<li>MyClassLoader 加载某个固定路径下的 class 文件</li>
<li>使用 MyClassLoader 加载了 <code>/Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/Main.class</code></li>
<li>然后调用 Main 类的 main 方法，main 方法中使用 <code>A a = new A();</code> 引用到了 A 类(<code>/Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/A.class</code>)</li>
<li>此时就会由 Main 类的类加载器 MyClassLoader 去尝试加载 A 类，于是输出中就可以看到 A 类的类加载器是 MyClassLoader</li>
</ul>
<p>完整输出</p>
<pre><code class="hljs">系统启动
hello, ClassLoader
com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.javademo</span>.JavaDemoApplication<span class="hljs-variable">$MyClassLoader</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="classforname"></a><a href="#classforname" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Class.forName()</h3>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)
    <span class="hljs-keyword">throws</span> ClassNotFoundException {
    Class&lt;?&gt; caller = Reflection.getCallerClass();
    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);
}

<span class="hljs-meta">@CallerSensitive</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String name, <span class="hljs-keyword">boolean</span> initialize,
                               ClassLoader loader)
    <span class="hljs-keyword">throws</span> ClassNotFoundException
{
    Class&lt;?&gt; caller = <span class="hljs-keyword">null</span>;
    SecurityManager sm = System.getSecurityManager();
    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// Reflective call to get caller class is only needed if a security manager</span>
        <span class="hljs-comment">// is present.  Avoid the overhead of making this call otherwise.</span>
        caller = Reflection.getCallerClass();
        <span class="hljs-keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) {
            ClassLoader ccl = ClassLoader.getClassLoader(caller);
            <span class="hljs-keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) {
                sm.checkPermission(
                    SecurityConstants.GET_CLASSLOADER_PERMISSION);
            }
        }
    }
    <span class="hljs-keyword">return</span> forName0(name, initialize, loader, caller);
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="hljs-keyword">boolean</span> initialize,
                                        ClassLoader loader,
                                        Class&lt;?&gt; caller)
</code></pre>
<ul>
<li><code>Class.forName(String className)</code> 使用的是调用这个方法的类的类加载器来加载这个新类，也就是与直接引用的方式是一致的，并且这个类会被初始化</li>
<li><code>forName(String name, boolean initialize, ClassLoader loader)</code> 使用的是我们手动传入的类加载器来加载这个新类，也就是说我们可以自己决定谁来加载这个类，并且可以控制是否初始化。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="总结-5"></a><a href="#总结-5" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<ul>
<li>在 A 类中引起 B 类的加载的时候，会使用 A 类的类加载器去加载 B 类</li>
<li>主要包括有 <code>A a = new A()</code> 这种直接引用和 <code>Class.forName(className)</code> 这种加载，两者都是使用 A 类的加载器去加载新类</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="两个不同的类加载器是否会让一个类初始化多次"></a><a href="#两个不同的类加载器是否会让一个类初始化多次" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>两个不同的类加载器是否会让一个类初始化多次</h2>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemoApplication</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>{
        System.out.println(<span class="hljs-string">"系统启动"</span>);
        MyClassLoader myClassLoader = <span class="hljs-keyword">new</span> MyClassLoader(
                <span class="hljs-string">"/Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo"</span>);
        MyClassLoader2 myClassLoader2 = <span class="hljs-keyword">new</span> MyClassLoader2(
                <span class="hljs-string">"/Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo"</span>);
        Class&lt;?&gt; a = myClassLoader.loadClass(<span class="hljs-string">"Main"</span>);
        Class&lt;?&gt; b = myClassLoader2.loadClass(<span class="hljs-string">"Main"</span>);
        System.out.println(a.getClassLoader().getClass().getName());
        System.out.println(b.getClassLoader().getClass().getName());
        System.out.println(a == b);
        Method mainMethod = a.getMethod(<span class="hljs-string">"main"</span>,String[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        Method mainMethod2 = b.getMethod(<span class="hljs-string">"main"</span>,String[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        mainMethod.invoke(<span class="hljs-keyword">null</span>, (Object) <span class="hljs-keyword">null</span>);
        mainMethod2.invoke(<span class="hljs-keyword">null</span>, (Object) <span class="hljs-keyword">null</span>);
        System.out.println(<span class="hljs-string">"系统结束"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>{
        <span class="hljs-keyword">private</span> Path startPath;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String startPath)</span></span>{
            <span class="hljs-comment">// MyClassLoader 实例的 parent 加载器将是系统类加载器 AppClassLoader</span>
            <span class="hljs-keyword">super</span>();
            <span class="hljs-keyword">this</span>.startPath = Paths.get(startPath);
        }
        <span class="hljs-meta">@SneakyThrows</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {
            Path classPath = startPath.resolve(name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>));
            <span class="hljs-keyword">byte</span>[] bytes = Files.readAllBytes(classPath);
            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyClassLoader</span></span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader2</span><span class="hljs-params">(String startPath)</span></span>{
            <span class="hljs-keyword">super</span>(startPath);
        }

        <span class="hljs-comment">/**
         * 先尝试自己加载，然后才转移给父类
         * <span class="hljs-doctag">@param</span> name
         * <span class="hljs-doctag">@param</span> resolve
         * <span class="hljs-doctag">@return</span>
         * <span class="hljs-doctag">@throws</span> ClassNotFoundException
         */</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException {
            Class&lt;?&gt; aClass = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> {
                aClass = findClass(name);
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.loadClass(name, resolve);
            }
            <span class="hljs-keyword">if</span>(resolve){
                resolveClass(aClass);
            }
            <span class="hljs-keyword">return</span> aClass;
        }
    }
}

<span class="hljs-comment">// /Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/Main.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        A a = <span class="hljs-keyword">new</span> A();
        a.hello();
        System.out.println(a.getClass().getClassLoader().getClass().getName());
    }
}

<span class="hljs-comment">// /Users/czp/workspace/projects/java-demo/src/main/java/com/example/javademo/A.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"hello, ClassLoader"</span>);
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs">系统启动
com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.javademo</span>.JavaDemoApplication<span class="hljs-variable">$MyClassLoader</span>
com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.javademo</span>.JavaDemoApplication<span class="hljs-variable">$MyClassLoader2</span>
false
Main 类被加载了
hello, ClassLoader
com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.javademo</span>.JavaDemoApplication<span class="hljs-variable">$MyClassLoader</span>
Main 类被加载了
hello, ClassLoader
com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.javademo</span>.JavaDemoApplication<span class="hljs-variable">$MyClassLoader2</span>
系统结束
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="总结-6"></a><a href="#总结-6" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<ul>
<li>两个不同的类加载器可以对一个类初始化多次</li>
<li>归根结底是因为使用了不同的加载器加载一个类之后，它在 JVM 看来压根儿就是毫不相干的两个类，哪怕他们的字节码完全一致</li>
<li>因此当我们使用 2 个不同的 ClassLoader 去加载相同的字节码之后，初始化是可以执行 2 次的</li>
<li>必须要主动使用了 Class 的功能，比如调用它的方法，获取它的字段，这样 JVM 才会主动去初始化这个类</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="classforname--和-classloaderloadclass-的区别"></a><a href="#classforname--和-classloaderloadclass-的区别" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Class.forName()  和 classLoader.loadClass() 的区别</h2>
<ul>
<li><code>Class.forName(className)</code>
<ul>
<li>约等于 <code>Class.forName(className, true, ClassLoader.getClassLoader(caller))</code></li>
<li>也就是说，它使用当前<strong>调用这个方法的类</strong>的类加载器来加载这个 className 对应的类</li>
<li>并且默认会执行类的初始化行为</li>
</ul></li>
<li><code>Class.forName(className, initialize, classLoader)</code>
<ul>
<li>我们可以控制这个类被加载后是否初始化</li>
<li>使用我们传入的 classLoader 来加载这个类</li>
</ul></li>
<li><code>classLoader.loadClass()</code>
<ul>
<li>使用这个类加载器来加载这个类</li>
<li>类不会被初始化，我们可以传入第二个参数表示类是否进行链接操作</li>
</ul></li>
<li>所以主要的区别在于 <code>Class.forName(className)</code> 会对类进行初始化操作</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="默认的线程上下文类加载器"></a><a href="#默认的线程上下文类加载器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认的线程上下文类加载器</h2>
<ul>
<li>每个线程有一个默认的线程上下文类加载器</li>
<li>每个线程将继承其父线程的上下文类加载器</li>
<li>初始的线程的上下文类加载器是 AppClassLoader</li>
<li>因此一般来说默认的线程上下文类加载器就是 AppClassLoader</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="为什么要有线程上下文类加载器"></a><a href="#为什么要有线程上下文类加载器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么要有线程上下文类加载器</h2>
<ul>
<li>当我们在类 A 里引用类 B 的时候，默认使用的是类 A 的类加载器去加载类 B</li>
<li>在 spi 机制中，java 只定义了一组接口，而具体的实现是第三方厂商去定义的，这就出现了一种情况
<ul>
<li>jdk 内部定义使用 spi 功能的时候，肯定是按照接口编程的，那么这些接口都是被 BootstrapClassLoader 加载的</li>
<li>而 spi 的具体实现都是厂商实现的，都是在 classpath 里，应该被 AppClassLoader 加载</li>
<li>jdk 内部使用 spi 的时候加载这些第三方类库，BootstrapClassLoader 是无法加载它们的，必须交给别的加载器去加载</li>
<li>因此其实是可以使用 AppClassLoader 去加载的，java 选择添加了线程上下文类加载器的方式，使用上下文类加载器去加载</li>
<li>我的理解是
<ul>
<li>使用 ClassLoader.getSystemClassLoader 也是可以加载 spi 的</li>
<li>使用线程上下文类加载器是为了添加一种机制：当 BootstrapClassLoader 无法加载某类的时候将控制权交给线程上下文类加载器</li>
<li>实际上此时将控制权交给 ClassLoader.getSystemClassLoader 也就是 AppClassLoader 也是可以的</li>
<li>唯一的不同是线程上下文类加载器会更灵活一点，不同的线程的类加载控制权可以交给不同的类加载器，如果是系统类加载器，那么全都交给了这一个加载器，不够灵活</li>
</ul></li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="怎么自定义类加载器"></a><a href="#怎么自定义类加载器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>怎么自定义类加载器</h2>
<ul>
<li>继承 ClassLoader</li>
<li>重写 findClass 方法</li>
<li>如果想要屏蔽双亲委托的行为，可以重写 loadClass 方法</li>
<li>findClass 中，最终要调用 defineClass 方法</li>
</ul>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>{
    <span class="hljs-keyword">private</span> Path startPath;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String startPath)</span></span>{
        <span class="hljs-comment">// MyClassLoader 实例的 parent 加载器将是系统类加载器 AppClassLoader</span>
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.startPath = Paths.get(startPath);
    }
    <span class="hljs-meta">@SneakyThrows</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {
        Path classPath = startPath.resolve(name.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>).concat(<span class="hljs-string">".class"</span>));
        <span class="hljs-keyword">byte</span>[] bytes = Files.readAllBytes(classPath);
        <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyClassLoader</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader2</span><span class="hljs-params">(String startPath)</span></span>{
        <span class="hljs-keyword">super</span>(startPath);
    }

    <span class="hljs-comment">/**
         * 先尝试自己加载，然后才转移给父类
         * <span class="hljs-doctag">@param</span> name
         * <span class="hljs-doctag">@param</span> resolve
         * <span class="hljs-doctag">@return</span>
         * <span class="hljs-doctag">@throws</span> ClassNotFoundException
         */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException {
        Class&lt;?&gt; aClass = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            aClass = findClass(name);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.loadClass(name, resolve);
        }
        <span class="hljs-keyword">if</span>(resolve){
            resolveClass(aClass);
        }
        <span class="hljs-keyword">return</span> aClass;
    }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="对双亲委托的一种理解"></a><a href="#对双亲委托的一种理解" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对双亲委托的一种理解</h2>
<pre><code class="hljs css language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">some</span><span class="hljs-params">()</span> </span>{
      B b = <span class="hljs-keyword">new</span> B();
      b.call();
  }
}
</code></pre>
<ul>
<li>考虑上面的代码，当我们实例化了一个 A 类的对象，调用它的 some 方法的时候</li>
<li>这个 A 类的实例将会引起 B 类的加载，<code>new B();</code> 在语义上基本等价于 <code>A.class.getClassLoader().loadClass(“B”).newInstance()</code>，也就是使用 A 类的加载器去尝试加载 B 类</li>
<li>如果 B 类就是 String 类，而 A 类的类加载器不遵守双亲委托，那么 B 类（String）的加载可能将会在中途被截胡，最后加载到的 String 可能就不是 BootstrapClassLoader 加载的 String 了</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="总结-7"></a><a href="#总结-7" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>
<ul>
<li><p>BootstrapClassLoader 加载核心类库</p></li>
<li><p>AppClassLoader 和 ExtClassLoader 都是被 BootstrapClassLoader 加载的</p></li>
<li><p>默认的线程上下文类加载器就是 AppClassLoader</p></li>
<li><p>任何一个对象实例，都可以通过 getClass 方法，获取到它的类</p></li>
<li><p>任何一个类（Class），都可以通过 getClassLoader，获取到加载这个类的 ClassLoader 实例</p></li>
<li><p>类的真正命名空间，是：classloader 实例 + 类的全限定类名。只有这两个都相等的才被认为是同一个类，如果 classloader 实例不同，就会出现 <code>java.lang.String can not cast to java.lang.String</code> 这类的错误</p></li>
<li><p>不同的类加载器为类提供了额外的命名空间，所以相同名称的类可以并存在 JAVA 虚拟机中</p></li>
<li><p>我们通常在 A 类里加载 B 类，有一个默认的语义</p>
<pre><code class="hljs css language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">some</span><span class="hljs-params">()</span> </span>{
      B b = <span class="hljs-keyword">new</span> B();
      b.call();
  }
}
</code></pre>
<ul>
<li><code>B b = new B();</code> 在语义上相当于 <code>B b = A.class.getClassLoader().loadClass(“B”).newInstance()</code></li>
<li>也就是说，我们在一个A类里面加载另一个B类的时候，默认使用的是A类的classloader去加载B类</li>
</ul></li>
<li><p>ClassLoader 的并行加载能力就是：一个 ClassLoader 是否可以被不同的线程同时使用 loadClass 去加载类，ExtClassLoader 和 AppClassLoader 都是可以的。我们自定义的类加载器可以使用</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">static</span> {
    ClassLoader.registerAsParallelCapable();
}
</code></pre>
<p>这种静态初始化，将 ClassLoader 注册为可以并行加载。如果不注册的话，loadClass 方法将会是一个线程同步的方法，同一时间只能有一个线程执行这个方法</p></li>
<li><p>Class.forName 会执行类的初始化 ，ClassLoader 的 loadClass 不会初始化，直到第一次真正使用该类才会由 JVM 执行初始化</p></li>
<li><p>类可以被初始化多次：前提的这个类被多个不同的类加载器加载</p></li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 3/23/2020</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/java系列/java-agent的相关内容"><span class="arrow-prev">← </span><span>java-agent的相关内容</span></a><a class="docs-next button" href="/docs/java系列/java的SecurityManager"><span class="function-name-prevnext">java的SecurityManager</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#问题">问题</a></li><li><a href="#说明">说明</a></li><li><a href="#参考">参考</a></li><li><a href="#bootstrapclassloader">BootstrapClassLoader</a></li><li><a href="#sunmisclauncher">sun.misc.Launcher</a><ul class="toc-headings"><li><a href="#总结">总结</a></li></ul></li><li><a href="#extclassloader">ExtClassLoader</a><ul class="toc-headings"><li><a href="#初始化逻辑">初始化逻辑</a></li><li><a href="#getextclassloader-方法">getExtClassLoader 方法</a></li><li><a href="#createextclassloader-方法">createExtClassLoader 方法</a></li><li><a href="#appclassloader">AppClassLoader</a></li><li><a href="#初始化逻辑-1">初始化逻辑</a></li></ul></li><li><a href="#classloader-类源码分析">ClassLoader 类源码分析</a><ul class="toc-headings"><li><a href="#说明-1">说明</a></li><li><a href="#静态变量">静态变量</a></li><li><a href="#实例变量">实例变量</a></li><li><a href="#静态方法">静态方法</a></li><li><a href="#实例方法">实例方法</a></li><li><a href="#总结-4">总结</a></li></ul></li><li><a href="#类如何与类加载器绑定在一起的">类如何与类加载器绑定在一起的</a></li><li><a href="#引用某个类的时候，使用的是什么-classloader">引用某个类的时候，使用的是什么 ClassLoader</a><ul class="toc-headings"><li><a href="#引用某个类的方式">引用某个类的方式</a></li><li><a href="#直接引用">直接引用</a></li><li><a href="#classforname">Class.forName()</a></li><li><a href="#总结-5">总结</a></li></ul></li><li><a href="#两个不同的类加载器是否会让一个类初始化多次">两个不同的类加载器是否会让一个类初始化多次</a><ul class="toc-headings"><li><a href="#总结-6">总结</a></li></ul></li><li><a href="#classforname--和-classloaderloadclass-的区别">Class.forName()  和 classLoader.loadClass() 的区别</a></li><li><a href="#默认的线程上下文类加载器">默认的线程上下文类加载器</a></li><li><a href="#为什么要有线程上下文类加载器">为什么要有线程上下文类加载器</a></li><li><a href="#怎么自定义类加载器">怎么自定义类加载器</a></li><li><a href="#对双亲委托的一种理解">对双亲委托的一种理解</a></li><li><a href="#总结-7">总结</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>