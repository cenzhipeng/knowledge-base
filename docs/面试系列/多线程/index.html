<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 线程状态"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## 线程状态"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/面试系列/多线程.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="线程状态"></a><a href="#线程状态" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程状态</h2>
<p>参考：<a href="https://my.oschina.net/goldenshaw?tab=newest&amp;catalogId=3277710">https://my.oschina.net/goldenshaw?tab=newest&amp;catalogId=3277710</a></p>
<pre><code class="hljs css language-java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State {
        <span class="hljs-comment">/**
         * Thread state for a thread which has not yet started.
         */</span>
        NEW,

        <span class="hljs-comment">/**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */</span>
        RUNNABLE,

        <span class="hljs-comment">/**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {<span class="hljs-doctag">@link</span> Object#wait() Object.wait}.
         */</span>
        BLOCKED,

        <span class="hljs-comment">/**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * &lt;ul&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> Object#wait() Object.wait} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> #join() Thread.join} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;p&gt;A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
         * on an object is waiting for another thread to call
         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
         * is waiting for a specified thread to terminate.
         */</span>
        WAITING,

        <span class="hljs-comment">/**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * &lt;ul&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> #sleep Thread.sleep}&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait} with timeout&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> #join(long) Thread.join} with timeout&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
         *   &lt;li&gt;{<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
         * &lt;/ul&gt;
         */</span>
        TIMED_WAITING,

        <span class="hljs-comment">/**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */</span>
        TERMINATED;
    }
</code></pre>
<ul>
<li>new
<ul>
<li>还没有调用 start 的线程，也就是我们刚创建的时候</li>
</ul></li>
<li>runnable
<ul>
<li>处于 runnable 状态下的线程正在 Java 虚拟机中执行，但它<strong>可能正在等待</strong>来自于操作系统的其它资源，比如处理器。</li>
</ul></li>
<li>blocked
<ul>
<li>正在等待监视器锁的状态</li>
<li>进入 synchronized 块的时候首先处于这一状态，等着获取锁</li>
<li>调用 <code>Object.wait()</code> 之后，被唤醒（notify）了之后重新进入同步块，那么就又进入了 blocked 状态</li>
</ul></li>
<li>waiting
<ul>
<li>不带参数的 <code>Object.wait()</code> 方法</li>
<li>不带参数的 <code>Thread.join()</code> 方法</li>
<li><code>LockSupport.park()</code> 方法</li>
<li>以上方法导致进入 waiting 状态</li>
</ul></li>
<li>timed_waiting
<ul>
<li><code>Thread.sleep()</code></li>
<li>带参数的 <code>Object.wait(time)</code> 方法</li>
<li>带参数的 <code>Thread.join(time)</code> 方法</li>
<li><code>LockSupport.parkNanos()</code> <code>LockSupport.parkUntil()</code> 这类带时间的方法</li>
</ul></li>
<li>terminated
<ul>
<li>结束状态</li>
</ul></li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/706569/201902/706569-20190217153339319-364986770.png" alt="img"></p>
<p><img src="../assets/706569-20190217153844611-518770169.png" alt="img"></p>
<p><img src="../assets/706569-20190217154821568-1447108849.png" alt="img"></p>
<h3><a class="anchor" aria-hidden="true" id="总结"></a><a href="#总结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<p>等待锁的状态就是 blocked，例如第一次进入 synchronized 块竞争的时候，或者 wait 了之后又被 notify 叫醒了再次进入 synchronized 块的时候。</p>
<p>当我们 IO 阻塞的时候是什么状态呢？其实是 Runnable 状态，这个是 JVM 层面的线程状态，实际上反映到底层操作系统线程的状态其实是 waiting 状态。</p>
<p>因此，JVM 和 操作系统的线程状态对应如下</p>
<p><img src="https://static.oschina.net/uploads/img/201612/14203501_73qS.png" alt="14203501_73qS.png (../assets/14203501_73qS.png)"></p>
<p>所以为什么说锁的消耗大：因为锁导致 JVM 线程进入了 blocked 状态，而反映到底层就是 waiting 状态，这个是需要进行系统调用的。</p>
<p>一旦进行系统调用就必须进入内核态，操作系统就要保存一堆上下文，导致效率低下。</p>
<p>因此：我们在进入 synchronized 块这种锁的时候，并不会立刻就进入 blocked 状态，而是先多试着去获取几次，实在是获取不到，我才使用系统调用对操作系统说：让我睡一会儿，有人释放锁了再叫我</p>
<p>（如果不主动调用系统调用将自己阻塞的话，就只能用循环的方式让自己进行忙等待了，那 CPU 就被白白浪费了，自旋锁也算是一种忙等，但是它只自旋少数次，用少量CPU损耗来避免线程切换的系统调用损耗）</p>
<h2><a class="anchor" aria-hidden="true" id="jvm-对锁的优化"></a><a href="#jvm-对锁的优化" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JVM 对锁的优化</h2>
<h3><a class="anchor" aria-hidden="true" id="不优化的时候是什么样子"></a><a href="#不优化的时候是什么样子" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不优化的时候是什么样子</h3>
<p>很多资料都是在说 JVM 对锁的优化的具体措施，但是都不怎么谈不优化的时候是什么样子，我觉得我可以梳理一下自己的理解</p>
<p>根据线程状态里的描述，多个线程进入同步块的时候，会去争抢这个锁，那么：</p>
<ul>
<li>抢到锁的线程只有一个</li>
<li>抢不到锁的线程应该怎么办？</li>
</ul>
<p>不优化的时候，抢不到锁的线程直接进入 blocked 状态（JVM 线程状态）。</p>
<p>也就是说调用系统调用，将自己进入到 waiting 状态（操作系统线程状态），由于这里要进行系统调用，因此就导致了性能低下，因为操作系统要进行上下文切换，保存上下文一大堆的工作。</p>
<h3><a class="anchor" aria-hidden="true" id="自旋锁"></a><a href="#自旋锁" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自旋锁</h3>
<p>由于上面不优化的时候性能很低，那么怎么办呢？其中自旋锁的思路就是：</p>
<ul>
<li>一个线程拿到锁执行的可能很短</li>
<li>因此我可以等它运行完了这很短的持有锁的时间，自己再去拿锁</li>
<li>所以我就跑一段循环，让自己进行一段时间的 忙等待，拖过这一阵子</li>
</ul>
<p>可以看到，自旋锁的主要思想就是，不直接进入 blocked 状态，而是进行一段时间的循环，实在是取不到锁了再进入到 blocked 状态</p>
<blockquote>
<p>这里可以考虑调整 JVM 自旋锁的次数来验证一下线程状态（-XX：PreBlockSpin），比如设置自旋 1 亿次，那么应该可以看到一个线程没拿到 synchronized 锁，但是是 Runnable 而不是 blocked 状态</p>
<p>注：上面的参数已经删除了，1.6 开始只提供自适应自旋锁</p>
</blockquote>
<p>JVM 现在有<strong>自适应自旋锁</strong>，就是：</p>
<ul>
<li>如果一个线程在某个锁上自旋获取过锁，那么 JVM 倾向于后续获取锁的时候继续自旋，自旋次数会增加</li>
<li>如果在某个锁上自旋很少能获取到锁，JVM 就觉得自旋的作用可能不大，后续可能直接跳过去不自旋了</li>
</ul>
<p>说白了就是会自行调整自旋的次数</p>
<h3><a class="anchor" aria-hidden="true" id="锁消除"></a><a href="#锁消除" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>锁消除</h3>
<p>JIT 编译的时候发现某段代码其实没有锁的竞争，就会把锁给消掉</p>
<p>说白了就是运行时的一些逃逸分析来做的。如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<h3><a class="anchor" aria-hidden="true" id="锁粗化"></a><a href="#锁粗化" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>锁粗化</h3>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。
如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<blockquote>
<p>我理解是说：对于同一个锁零碎的频繁加锁，不如直接加一个大锁效率高。因为加锁的次数多，可能导致线程调度的次数多</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="轻量级锁"></a><a href="#轻量级锁" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>轻量级锁</h3>
<p>轻量级锁是相对于重量级锁而言的：</p>
<ul>
<li>重量级锁就是说我们一开始 synchronized 的实现，底层是通过操作系统的互斥量这个 API 来实现的，一个线程拿到这个互斥量之后，其它线程当然就拿不到了，这个就是 synchronized 判断谁拿到锁的实现方式</li>
<li>轻量级锁则是 JDK 1.6 之后的一种实现 synchronized 的方式，先使用 CAS 把锁对象的 mark world 指向自己，如果失败了说明有人跟自己竞争，直接升级到重量级锁（把自己挂机起来）</li>
<li>这里升级重量级锁我理解就是让自己这个线程挂机（进入 blocked 状态），否则就只能空转了</li>
</ul>
<blockquote>
<p>轻量级锁适用于竞争很少的场景，实际上没多少竞争，所以靠一手 CAS 即可</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="偏向锁"></a><a href="#偏向锁" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>偏向锁</h3>
<ul>
<li>当锁第一次被线程获取的时候，线程使用 CAS 把锁的拥有者改成自己的线程ID，同时设置它的标志位，表示这个锁处于偏向模式</li>
<li>以上表示：锁第一次被获取之前，从标志位可以看出不是偏向锁，所以线程会执行上面的操作</li>
<li>等到后面这个线程再获取这个对象的锁的时候，看到线程 ID 是自己，并且是偏向锁，那就直接拿走锁了</li>
<li>这个就消除了后续的线程的 CAS 操作</li>
<li>如果有其它线程在竞争，那么它看到这个锁是偏向锁了，并且不是指向自己的，就变成了一个轻量级锁，使用 CAS 将锁撤销偏向锁，此时就变成了一个轻量级锁</li>
</ul>
<blockquote>
<p>偏向锁主要也是适用于竞争少的场景</p>
</blockquote>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 4/8/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#线程状态">线程状态</a><ul class="toc-headings"><li><a href="#总结">总结</a></li></ul></li><li><a href="#jvm-对锁的优化">JVM 对锁的优化</a><ul class="toc-headings"><li><a href="#不优化的时候是什么样子">不优化的时候是什么样子</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#锁消除">锁消除</a></li><li><a href="#锁粗化">锁粗化</a></li><li><a href="#轻量级锁">轻量级锁</a></li><li><a href="#偏向锁">偏向锁</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>