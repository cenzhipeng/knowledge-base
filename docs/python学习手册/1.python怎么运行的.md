---
id: python怎么运行的
title: 本文内容
sidebar_label: python怎么运行的
---



## python解释器

- 当我们说安装 python 的时候，实际上就是安装了 python 解释器，以及一系列的 python 包（标准库）
- 解释器本身可能是 C 语言写的或者 java 写的等等
- python 解释器的地位其实跟 java 虚拟机差不了太多



## 字节码编译

执行程序时，python 其实也是会将源码编译成字节码的（pyc 文件）

在 python 3.2 之前（所有的 python2）：

- 除了主模块之外，被导入的其它模块的都会在模块文件所在路径下生成同名的 pyc 文件
- 主模块如果也作为一个模块被导入到了其他模块中，主模块也会生成同名的 pyc 文件

在 python 3.2 之后：

- 除了主模块，被导入的其它模块的都会在模块文件所在路径下生成 `__pycache__` 目录，然后在目录里放上自己这个模块对应的 pyc 文件，同时 pyc 文件名会做一些补充，会写上编译这个 pyc 的 python 版本，这样就可以避免很多重复编译（多个版本的 pyc 共存，解释器需要的时候自行去取自己对应的版本）
- 主模块如果也作为一个模块被导入到了其他模块中，也是一样的在自己这个目录下的 `__pycache__` 目录里放上自己的 pyc

### 判断重新编译

主要看时间戳，py 文件修改时间比 pyc 更晚的话就会触发重新编译。

另外则是看 python 版本，python 解释器发现 pyc 版本比自己低就会重新编译

### 无法写入 pyc 的情形

如果 python 解释器没法将 pyc 写在文件里（例如没有写入权限），python 一样可以运行，此时 pyc 会存储在内存里

### 只有 pyc 没有 py 文件

这时 python 解释器一样能执行

### 交互式命令行

此时不生成 pyc



### PVM

PVM 其实就是 python 解释器，它读取 pyc 字节码，然后一条一条的执行。

其实整个模式跟 java 真的挺像的



## python 运行脚本

### shebang

- `#!/usr/local/bin/python`：相当于硬编码 python 解释器的安装路径
- `#!/usr/bin/env python`：相当于我们在 shell 里直接输入 python。会自动在 path 里寻找 python 的安装路径

其实差别不大，后面那种可能相对来说会好一点点

