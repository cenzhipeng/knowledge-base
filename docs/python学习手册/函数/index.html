<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## map、filter、reduce"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## map、filter、reduce"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/python学习手册/7.函数.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="map、filter、reduce"></a><a href="#map、filter、reduce" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>map、filter、reduce</h2>
<p>这几个函数现在其实用的不多了，因为可以用推导表达式替代，例如：</p>
<ul>
<li><code>map(func,some_list)</code>  等价于 <code>[func(x) for x in some_list]</code></li>
<li><code>filter</code> 等价于 <code>[x for x in some_list if x ...]</code></li>
<li><code>reduce</code> 基本用的很少，一般用 sum</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="all、any"></a><a href="#all、any" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>all、any</h2>
<p>这两个还有点用处</p>
<ul>
<li><code>all(iterable)</code>：当所有元素都是 True 时返回 True</li>
<li><code>any(iterable)</code>：有元素是 True 时返回 True</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="传参方式"></a><a href="#传参方式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传参方式</h2>
<ul>
<li><p>定位参数：<code>def func(a, b, c)</code> 这里 abc 都是定位参数</p></li>
<li><p>变长参数：<code>def func(a, *b)</code> 这里 b 将是元组，可以传入多个参数例如 <code>func(1, 2, 3)</code>，b 将是 <code>(2, 3)</code></p></li>
<li><p>捕获关键字参数：<code>def func(a, *b, **c)</code> 这里 b 依然是元组，c 是字典，捕获后面所有的关键字参数，例如 <code>func(1, 2, x=3, y=3)</code> 这里 c 将是 <code>{'x': 3, 'y': 3}</code></p></li>
<li><p>限定关键字参数：这种参数只能被使用关键字的方式传入（python 3 的特性），使用方式如下：</p>
<ul>
<li><code>def func(a, *b, key=None, **c)</code>，这里的 key 参数只能通过 func(1, 2, key=xxx) 的方式传入</li>
<li>如果不想要中间的变长参数，需要使用 <code>def f(a, *, b=None)</code> 这种定义方式</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="可调用的对象"></a><a href="#可调用的对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可调用的对象</h2>
<p>函数是可以调用的，但是其实我们自己创建的对象也可以被调用，可以使用 <code>callable()</code> 函数来判断一个对象是否可以被调用。有 7 种可调用对象：</p>
<ul>
<li>用户定义的函数（def 和 lambda）</li>
<li>内置函数</li>
<li>内置方法</li>
<li>方法</li>
<li>类
<ul>
<li>调用时，会使用类的 <code>__new__</code> 方法创建一个实例，然后运行 <code>__init__</code> 方法（其实就是创建类的对象的一般过程）</li>
<li>通常，调用类会创建那个类的实例，不过覆盖 <code>__new__</code> 方法的话，也可能出现其他行为</li>
</ul></li>
<li>类的实例
<ul>
<li>如果类定义了 <code>__call__</code> 方法，那么它的实例可以作为函数调用</li>
<li>也就是说类生成的实例对象可以被直接调用</li>
</ul></li>
<li>生成器函数
<ul>
<li>使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="自定义可调用对象"></a><a href="#自定义可调用对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自定义可调用对象</h2>
<p>我们只需要为对象添加一个 <code>__call__</code> 方法，就可以让这个对象可被调用，表现的像是一个函数</p>
<pre><code class="hljs"># coding=utf<span class="hljs-number">-8</span>
<span class="hljs-keyword">class</span> <span class="hljs-symbol">AAA:
    <span class="hljs-symbol">def</span></span> <span class="hljs-symbol">__call__</span>(<span class="hljs-symbol">self, </span>*<span class="hljs-symbol">args, </span>**<span class="hljs-symbol">kwargs</span>):
        <span class="hljs-symbol">print</span> '这个对象可以被调用'


<span class="hljs-symbol">a</span> = <span class="hljs-symbol">AAA</span>()
<span class="hljs-symbol">a</span>()
输出：这个对象可以被调用
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="函数内省"></a><a href="#函数内省" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数内省</h2>
<ul>
<li>首先我们知道，函数就是一个对象，而对象都是有一些属性的，所以函数也有很多属性</li>
<li>dir(obj) 可以返回这个对象的所有属性</li>
<li>因此使用 <code>sorted(set(dir(func)) - set(dir(obj)))</code> 来获得函数有而普通对象没有的属性</li>
</ul>
<pre><code class="hljs"><span class="hljs-variable">class</span> <span class="hljs-variable">C</span>: <span class="hljs-variable">pass</span>


<span class="hljs-variable">obj</span> = <span class="hljs-function"><span class="hljs-title">C</span>()</span>


<span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">func</span>():
    <span class="hljs-variable">pass</span>


<span class="hljs-variable">print</span> <span class="hljs-title">sorted</span>(<span class="hljs-title">set</span>(<span class="hljs-title">dir</span>(<span class="hljs-variable">func</span>)) - <span class="hljs-title">set</span>(<span class="hljs-title">dir</span>(<span class="hljs-variable">obj</span>)))</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="函数属性"></a><a href="#函数属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数属性</h3>
<p>经过以上代码，可以获取用户定义函数对象特有的属性：</p>
<table>
<thead>
<tr><th>名称</th><th>类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr>
<tr><td><code>__call__</code></td><td>method-wrapper</td><td>实现 () 运算符;即可调用对象协议</td></tr>
<tr><td><code>__closure__</code></td><td>tuple</td><td>函数闭包，即自由变量的绑定(通常是 None)</td></tr>
<tr><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr>
<tr><td><code>__defaults__</code></td><td>tuple</td><td>形式参数的默认值</td></tr>
<tr><td><code>__get__</code></td><td>method-wrapper</td><td>实现只读描述符协议</td></tr>
<tr><td><code>__globals__</code></td><td>dict</td><td>函数所在模块中的全局变量</td></tr>
<tr><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr>
<tr><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr>
<tr><td><code>__qualname__</code></td><td>str</td><td>函数的限定名称，如 Random.choice</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" id="参数内省"></a><a href="#参数内省" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参数内省</h3>
<pre><code class="hljs">def clip(text, max_len=<span class="hljs-number">80</span>):
    <span class="hljs-keyword">pass</span>


from inspect <span class="hljs-keyword">import</span> signature, <span class="hljs-keyword">Parameter</span>

sig = signature(clip)
<span class="hljs-built_in">print</span>(sig)
param: <span class="hljs-keyword">Parameter</span> # 表示这是个 <span class="hljs-keyword">Parameter</span> 对象，这是 python <span class="hljs-number">3</span> 的一种语法
for <span class="hljs-keyword">name</span>, param <span class="hljs-keyword">in</span> sig.parameters.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'[%s] param default value is %s'</span> % (<span class="hljs-keyword">name</span>, param.<span class="hljs-keyword">default</span>)
</code></pre>
<p>输出</p>
<pre><code class="hljs">(text, <span class="hljs-attribute">max_len</span>=80)
[text] param<span class="hljs-built_in"> default </span>value is &lt;class <span class="hljs-string">'inspect._empty'</span>&gt;
[max_len] param<span class="hljs-built_in"> default </span>value is 80
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="不要使用可变对象作为默认参数"></a><a href="#不要使用可变对象作为默认参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不要使用可变对象作为默认参数</h3>
<p>由于函数的参数默认值是保存在函数这个对象的 <code>__defaults__</code> 属性里的，所以如果我们使用可变对象作为参数默认值的话，当我们在函数中就地修改这个参数时，函数的默认值相当于也被我们给修改了（因为当我们多次调用同一个函数，这些函数访问的参数默认值都是同一个对象），这种情况会造成很诡异的bug，所以最好不要使用可变对象（例如 list）作为函数参数的默认值</p>
<h2><a class="anchor" aria-hidden="true" id="偏函数"></a><a href="#偏函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>偏函数</h2>
<p>简单来说就是，一个函数可能需要多个参数才能调用，我们可以先传递一部分函数，生成一个新的函数，这个新的函数只需要传递另外缺少的一部分函数即可</p>
<pre><code class="hljs"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial
<span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul

new_mul = partial(mul, <span class="hljs-number">3</span>)
print(new_mul(<span class="hljs-number">5</span>))
</code></pre>
<blockquote>
<p>类的实例调用函数的时候，其实就可以看做是将实例传递到了 self 参数，生成了新的偏函数然后将其调用的</p>
</blockquote>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 7/26/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#map、filter、reduce">map、filter、reduce</a></li><li><a href="#all、any">all、any</a></li><li><a href="#传参方式">传参方式</a></li><li><a href="#可调用的对象">可调用的对象</a></li><li><a href="#自定义可调用对象">自定义可调用对象</a></li><li><a href="#函数内省">函数内省</a><ul class="toc-headings"><li><a href="#函数属性">函数属性</a></li><li><a href="#参数内省">参数内省</a></li><li><a href="#不要使用可变对象作为默认参数">不要使用可变对象作为默认参数</a></li></ul></li><li><a href="#偏函数">偏函数</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>