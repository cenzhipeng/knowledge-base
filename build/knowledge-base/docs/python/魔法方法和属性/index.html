<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 魔法方法"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="## 魔法方法"/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/python/11.魔法方法和属性.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="魔法方法"></a><a href="#魔法方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>魔法方法</h2>
<p>python 的很多功能都是通过魔法方法来实现的，例如我们调用 <code>len(a)</code> 的时候，实际上会调用 <code>a.__len__()</code> 方法</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A:
    <span class="hljs-symbol">def</span></span> <span class="hljs-symbol">__len__</span>(<span class="hljs-symbol">self</span>):
        <span class="hljs-symbol">return</span> <span class="hljs-symbol">3</span>


<span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()
<span class="hljs-symbol">print</span>(<span class="hljs-symbol">len</span>(<span class="hljs-symbol">a</span>))
</code></pre>
<p>上述代码将会输出 3。</p>
<p>像这样的方法和属性称为魔法方法魔法属性</p>
<h2><a class="anchor" aria-hidden="true" id="构造函数"></a><a href="#构造函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构造函数</h2>
<p><code>__init__</code> 方法就是对象的构造函数</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A:
    <span class="hljs-symbol">def</span></span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):
        <span class="hljs-symbol">print</span>('<span class="hljs-symbol">A</span>的对象被构造了')

    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__len__</span>(<span class="hljs-symbol">self</span>):
        <span class="hljs-symbol">return</span> <span class="hljs-symbol">3</span>


<span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()
</code></pre>
<blockquote>
<p>python 也提供了 <code>__del__</code> 析构函数，但是尽量不要使用它</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="继承时的调用"></a><a href="#继承时的调用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>继承时的调用</h3>
<p>子类继承父类时，必须显式调用父类的构造函数，以此正确地初始化父类对象，从而可以使用到父类所具有的属性。跟 java 中不同的是，java 中的子类会自动调用父类的无参构造函数。而 python 中并不会有这种默认行为，所以我们必须显式调用父类构造函数。</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'A的对象被构造了'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-title">A</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">super</span>().__init_<span class="hljs-number">_</span>()
        print(<span class="hljs-string">'B的对象被构造了'</span>)


b = B()
b.hello()
</code></pre>
<p>以上是新的 python 3 中的常用代码，在老代码中应该是这样：</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'A的对象被构造了'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-title">A</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        A.__init_<span class="hljs-number">_</span>(<span class="hljs-keyword">self</span>)
        print(<span class="hljs-string">'B的对象被构造了'</span>)


b = B()
b.hello()
</code></pre>
<p>或者是下面：</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, a)</span></span>:
        print(<span class="hljs-string">'A的对象被构造了%s'</span> % a)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-title">A</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">super</span>(B, <span class="hljs-keyword">self</span>).__init_<span class="hljs-number">_</span>(<span class="hljs-number">3</span>)
        print(<span class="hljs-string">'B的对象被构造了'</span>)


b = B()
b.hello()
</code></pre>
<p>也就是说：<code>super(B, self)</code> 等价于 <code>super()</code></p>
<h3><a class="anchor" aria-hidden="true" id="小结"></a><a href="#小结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结</h3>
<ul>
<li><code>__init__</code> 方法就是通常所说的构造函数</li>
<li>python 实际上是构造一个对象之后，然后再调用这个对象的 <code>__init__</code> 方法</li>
<li><code>super()</code> 实际上返回了父类的对象，我们可以用其调用父类的方法和属性</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="元素访问"></a><a href="#元素访问" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元素访问</h2>
<h3><a class="anchor" aria-hidden="true" id="集合长度-len"></a><a href="#集合长度-len" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>集合长度 len</h3>
<p><code>__len__(self)</code>：返回集合的项数，对于列表来说就是列表元素个数，对于映射来说就是键值对数量。当我们调用 <code>len(a)</code> 背后就是调用了 <code>a.__len__()</code> 方法。如果 <code>__len__</code> 返回零(且没有实现覆盖这种行为的 <code>__nonzero__</code> 方法)，对象在布尔上下文中将被视为假</p>
<p><code>len(a) == a.__len__()</code></p>
<h3><a class="anchor" aria-hidden="true" id="元素访问-1"></a><a href="#元素访问-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元素访问</h3>
<p><code>__getitem__(self, key)</code>：返回索引值对应的元素。对序列来说就是数字下标，对映射来说则可能是任何类型。这个方法实际上对应了方括号访问的语法，也就是说：</p>
<p><code>a[0] == a.__getitem__(0)</code></p>
<p>验证代码如下：</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A:
    <span class="hljs-symbol">def</span></span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):
        <span class="hljs-symbol">print</span>('<span class="hljs-symbol">A</span>的对象被构造了')

    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__getitem__</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">item</span></span>):
        <span class="hljs-symbol">print</span>('<span class="hljs-symbol">__getitem__</span> 被调用了')
        <span class="hljs-symbol">return</span> <span class="hljs-symbol">item</span>


<span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()
<span class="hljs-symbol">print</span>(<span class="hljs-symbol">a</span>[<span class="hljs-symbol">5</span>])
</code></pre>
<p>输出：</p>
<pre><code class="hljs">A的对象被构造了
__getitem__ 被调用了
<span class="hljs-number">5</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="元素赋值"></a><a href="#元素赋值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元素赋值</h3>
<p><code>__setitem__(self, key, value)</code>：将索引对应的值进行赋值，对应于赋值语法如下：</p>
<p><code>a[0] = 2</code> 等价于 <code>a.__setitem__(0, 2)</code></p>
<p>验证代码如下：</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'A的对象被构造了'</span>)
        <span class="hljs-keyword">self</span>.data = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'__getitem__ 被调用了'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.data[item]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key, value)</span></span>:
        print(<span class="hljs-string">'__setitem__ 被调用了'</span>)
        <span class="hljs-keyword">self</span>.data[key] = value


a = A()
a[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>
print(a[<span class="hljs-number">3</span>])
</code></pre>
<p>输出如下：</p>
<pre><code class="hljs">A的对象被构造了
<span class="hljs-strong">__setitem__</span> 被调用了
<span class="hljs-strong">__getitem__</span> 被调用了
5
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="元素删除"></a><a href="#元素删除" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元素删除</h3>
<p><code>__delitem__(self, key)</code>：删除元素的时候调用的方法，对应的语法如下</p>
<p><code>del a[3]</code> 等价于 <code>a.__delitem__(3)</code></p>
<p>验证代码如下：</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'A的对象被构造了'</span>)
        <span class="hljs-keyword">self</span>.data = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'__getitem__ 被调用了'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.data[item]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key, value)</span></span>:
        print(<span class="hljs-string">'__setitem__ 被调用了'</span>)
        <span class="hljs-keyword">self</span>.data[key] = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delitem__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key)</span></span>:
        print(<span class="hljs-string">'__delitem__ 被调用了'</span>)
        del <span class="hljs-keyword">self</span>.data[key]


a = A()
a[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>
del a[<span class="hljs-number">3</span>]
</code></pre>
<p>输出：</p>
<pre><code class="hljs">A的对象被构造了
<span class="hljs-strong">__setitem__</span> 被调用了
<span class="hljs-strong">__delitem__</span> 被调用了
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="额外要求"></a><a href="#额外要求" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>额外要求</h3>
<p>对于以上的几种魔法方法，还有一些其它要求，当然，我们覆盖这些方法的时候，不满足要求也不是不可以，但是这样做的话就不符合一些接口和协议的规范了。</p>
<ul>
<li>对于序列，如果键为负整数，应从末尾往前数。换而言之，<code>x[-n] == x[len(x)-n]</code></li>
<li>如果键的类型不合适(如对序列使用字符串键)，引发 TypeError 异常</li>
<li>对于序列，如果索引的类型是正确的，但不在允许的范围内，应引发 IndexError 异常</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="get、set-属性方法"></a><a href="#get、set-属性方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>get、set 属性方法</h2>
<p>java 里面，我们一般定义一个对象属性，然后为这个属性设置get、set方法，这种做法其实有点蠢说实话。</p>
<p>python 里面，一般的属性可能直接就通过属性名访问了，但是这样也会失去对属性值的控制，例如一个 age 属性，结果我们将其设置一个字符串进来。如果我们想要对属性值进行检查，那么就应该设置get、set方法。</p>
<p>最简单的方式当然就是和java一样，先定义属性，然后额外定义get、set方法。python中则提供了另一种方式，称为 property</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.width = <span class="hljs-number">0</span>
        <span class="hljs-keyword">self</span>.height = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.width, <span class="hljs-keyword">self</span>.height

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_size</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, size)</span></span>:
        <span class="hljs-keyword">self</span>.width, <span class="hljs-keyword">self</span>.height = size

    size = property(get_size, set_size)


rect = Rectangle()
rect.size = <span class="hljs-number">3</span>, <span class="hljs-number">10</span>
print(rect.size)
</code></pre>
<p>通过 <code>size = property(get_size, set_size)</code> 创建了一个 size 属性。property 有四个参数分别是：</p>
<ul>
<li>访问器 get 方法</li>
<li>赋值函数 set 方法</li>
<li>删除函数 del 方法</li>
<li>属性文档字符串</li>
</ul>
<blockquote>
<p>当我们访问 rect.size 就会访问到 Rectangle.size，而由于 <code>Rectangle.size = property(get_size, set_size)</code> 是一个属性，因此最终使用了这里定义的 get、set</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="静态方法和类方法"></a><a href="#静态方法和类方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态方法和类方法</h2>
<p>两者的区别：静态方法不需要状态参数，只需要自己所需的参数。类方法需要状态参数：cls，也就是这个类对象本身</p>
<h3><a class="anchor" aria-hidden="true" id="静态方法"></a><a href="#静态方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态方法</h3>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">static_func</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"静态方法"</span>)


A.static_func() <span class="hljs-comment"># 正确输出</span>
a = A()
a.static_func() <span class="hljs-comment"># 报错</span>
</code></pre>
<p>不熟悉 python 的话，很容易将上面的方法当成静态方法的写法，实际是不正确的。当使用对象访问的时候访问不到这个方法。应该这样写</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">static_func</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"静态方法"</span>)

    static_func = staticmethod(static_func)


A.static_func()  <span class="hljs-comment"># 正确输出</span>
a = A()
a.static_func()  <span class="hljs-comment"># 正确输出</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="类方法"></a><a href="#类方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类方法</h3>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    x = <span class="hljs-number">10</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">static_func</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"静态方法"</span>)

    static_func = staticmethod(static_func)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">class_func</span><span class="hljs-params">(cls)</span>:</span>
        print(<span class="hljs-string">"类方法,x=%s"</span> % cls.x)

    class_func = classmethod(class_func)


A.class_func()  <span class="hljs-comment"># 正确输出</span>
a = A()
a.class_func()  <span class="hljs-comment"># 正确输出</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="访问对象属性"></a><a href="#访问对象属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问对象属性</h2>
<h3><a class="anchor" aria-hidden="true" id="访问属性"></a><a href="#访问属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问属性</h3>
<p><code>__getattribute__(self, name)</code>：当访问对象属性的时候调用，作用有点像是 property，但是不完全一样。property 属性的 get 访问器，只针对这一个属性的访问，而这个魔法方法 <code>__getattribute__(self, name)</code> 则是在对象的所有属性被访问时都会调用（包括方法）</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被访问了'</span> % item)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>(A, <span class="hljs-keyword">self</span>).__getattribute_<span class="hljs-number">_</span>(item)  <span class="hljs-comment"># 为了不无限递归，需要使用super的方法</span>


a = A()
a.hello()
a.a
</code></pre>
<p>输出：</p>
<pre><code class="hljs">对象的 <span class="hljs-selector-attr">[hello]</span> 属性被访问了
<span class="hljs-selector-tag">hello</span>
对象的 <span class="hljs-selector-attr">[a]</span> 属性被访问了
</code></pre>
<blockquote>
<p>显然，我们可以用这个方法做一定的拦截，比如篡改对象的属性</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="访问不存在的属性"></a><a href="#访问不存在的属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问不存在的属性</h3>
<p><code>__getattr__(self, name)</code>：这个方法在访问对象不存在的属性的时候调用</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被访问了'</span> % item)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>(A, <span class="hljs-keyword">self</span>).__getattribute_<span class="hljs-number">_</span>(item)  <span class="hljs-comment"># 为了不无限递归，需要使用super的方法</span>


a = A()
a.x
</code></pre>
<p>输出：</p>
<pre><code class="hljs">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):
  <span class="hljs-keyword">File</span> <span class="hljs-string">"/Users/czp/workspace/projects/python-demo/test.py"</span>, line <span class="hljs-number">14</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;
    a.x
  <span class="hljs-keyword">File</span> <span class="hljs-string">"/Users/czp/workspace/projects/python-demo/test.py"</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> __getattribute__
    <span class="hljs-keyword">return</span> super(A, <span class="hljs-keyword">self</span>).__getattribute__(item)  <span class="hljs-comment"># 为了不无限递归，需要使用super的方法</span>
AttributeError: <span class="hljs-string">'A'</span> <span class="hljs-keyword">object</span> has <span class="hljs-keyword">no</span> <span class="hljs-keyword">attribute</span> <span class="hljs-string">'x'</span>
对象的 [x] 属性被访问了
</code></pre>
<p>显然 a 对象没有 x 这个属性，此时我们可以定义这个魔法方法，比如将对象不存在的属性都改为这个属性名称字符串</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被访问了'</span> % item)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>(A, <span class="hljs-keyword">self</span>).__getattribute_<span class="hljs-number">_</span>(item)  <span class="hljs-comment"># 为了不无限递归，需要使用super的方法</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性不存在'</span> % item)
        <span class="hljs-keyword">return</span> item  <span class="hljs-comment"># 不存在的属性直接返回这个属性名称字符串</span>


a = A()
print(a.x)
</code></pre>
<p>输出：</p>
<pre><code class="hljs">对象的 [<span class="hljs-symbol">x</span>] 属性被访问了
对象的 [<span class="hljs-symbol">x</span>] 属性不存在
<span class="hljs-symbol">x</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="给属性赋值"></a><a href="#给属性赋值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>给属性赋值</h3>
<p><code>__setattr__(self, name, value)</code>：在给属性赋值的时候调用</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被访问了'</span> % item)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>(A, <span class="hljs-keyword">self</span>).__getattribute_<span class="hljs-number">_</span>(item)  <span class="hljs-comment"># 为了不无限递归，需要使用super的方法</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key, value)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被赋值了 [%s]'</span> % (key, value))


a = A()
a.b = <span class="hljs-number">3</span>
</code></pre>
<p>输出：</p>
<pre><code class="hljs">对象的 <span class="hljs-selector-attr">[a]</span> 属性被赋值了 <span class="hljs-selector-attr">[3]</span>
对象的 <span class="hljs-selector-attr">[b]</span> 属性被赋值了 <span class="hljs-selector-attr">[3]</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="删除属性"></a><a href="#删除属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除属性</h3>
<p><code>__delattr__(self, name)</code>：删除属性的时候调用这个方法</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)


a = A()
del a.a
print(a.a)
</code></pre>
<p>输出：</p>
<pre><code class="hljs">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):
  <span class="hljs-keyword">File</span> <span class="hljs-string">"/Users/czp/workspace/projects/python-demo/test.py"</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;
    print(a.a)
AttributeError: <span class="hljs-string">'A'</span> <span class="hljs-keyword">object</span> has <span class="hljs-keyword">no</span> <span class="hljs-keyword">attribute</span> <span class="hljs-string">'a'</span>
</code></pre>
<p>那么我们定义这个魔法方法：</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delattr__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被删除了'</span> % item)


a = A()
del a.a
print(a.a)
</code></pre>
<p>删除：</p>
<pre><code class="hljs">对象的 [a] 属性被删除了
<span class="hljs-number">3</span>
</code></pre>
<p>显然，因为我们的重写，导致这个属性并没被删除，那么怎么才能不妨碍删除呢</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.a = <span class="hljs-number">3</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        print(<span class="hljs-string">'hello'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delattr__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span>:
        print(<span class="hljs-string">'对象的 [%s] 属性被删除了'</span> % item)
        <span class="hljs-keyword">super</span>(A, <span class="hljs-keyword">self</span>).__delattr_<span class="hljs-number">_</span>(item)


a = A()
del a.a
print(a.a)
</code></pre>
<p>依然是调用父对象的删除方法</p>
<h2><a class="anchor" aria-hidden="true" id="迭代器协议"></a><a href="#迭代器协议" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>迭代器协议</h2>
<p>可迭代的对象：可迭代的对象具有 <code>__iter__</code> 方法，并且返回一个迭代器对象</p>
<p>迭代器对象：迭代器对象具有方法 <code>__next__</code> ，直到返回 None 表示迭代终止</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">return</span> Iter([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iter</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, data)</span></span>:
        <span class="hljs-keyword">self</span>.data = data
        <span class="hljs-keyword">self</span>.index = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-symbol">try:</span>
            cur = <span class="hljs-keyword">self</span>.data[<span class="hljs-keyword">self</span>.index]
        except <span class="hljs-symbol">IndexError:</span>
            raise StopIteration from None  <span class="hljs-comment"># 迭代器终止应该抛异常 StopIteration</span>
        <span class="hljs-keyword">self</span>.index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> cur

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:  <span class="hljs-comment"># 迭代器自己返回自己是个很好的模式</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>


a = A()
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-symbol">a:</span>
    print(num)
</code></pre>
<p>输出：</p>
<pre><code class="hljs"><span class="hljs-number">1</span>
<span class="hljs-number">3</span>
<span class="hljs-number">5</span>
<span class="hljs-number">7</span>
<span class="hljs-number">9</span>
</code></pre>
<blockquote>
<ul>
<li>以前版本的python迭代器可能包含的是 <code>next</code> 方法而不是 <code>__next__</code> 方法</li>
<li>包含 <code>__iter__</code> 方法的对象是可迭代的对象，也就是可以用于 for 循环迭代</li>
<li>包含 <code>__next__</code> 方法的对象是迭代器对象，也就是具体的被迭代的对象</li>
<li>使用 <code>next(a)</code> 等价于 <code>a.__next__()</code></li>
</ul>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="将可迭代对象转为-list"></a><a href="#将可迭代对象转为-list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将可迭代对象转为 list</h3>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">return</span> Iter([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iter</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, data)</span></span>:
        <span class="hljs-keyword">self</span>.data = data
        <span class="hljs-keyword">self</span>.index = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-symbol">try:</span>
            cur = <span class="hljs-keyword">self</span>.data[<span class="hljs-keyword">self</span>.index]
        except <span class="hljs-symbol">IndexError:</span>
            raise StopIteration from None  <span class="hljs-comment"># 迭代器终止应该抛异常 StopIteration</span>
        <span class="hljs-keyword">self</span>.index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> cur

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:  <span class="hljs-comment"># 迭代器自己返回自己是个很好的模式</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>


a = A()
b = a.__iter_<span class="hljs-number">_</span>()
print(list(b) == [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])  <span class="hljs-comment"># True</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="生成器"></a><a href="#生成器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成器</h2>
<p>生成器有点类似于迭代器，也是不断调用生成器的 <code>__next__</code> 方法从而不断获取值，也可以被迭代。但是生成器有专用的语法：yield</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_generator</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>):
        <span class="hljs-keyword">yield</span> i


generator = create_generator()
print(generator.__next__())
print(generator.__next__())
print(generator.__next__())
</code></pre>
<p>输出</p>
<pre><code class="hljs"><span class="hljs-number">0</span>
<span class="hljs-number">3</span>
<span class="hljs-number">6</span>
</code></pre>
<p>迭代一个生成器</p>
<pre><code class="hljs"><span class="hljs-attr">def</span> <span class="hljs-string">create_generator():</span>
    <span class="hljs-attr">for</span> <span class="hljs-string">i in range(0, 100, 3):</span>
        <span class="hljs-attr">yield</span> <span class="hljs-string">i</span>


<span class="hljs-attr">generator</span> = <span class="hljs-string">create_generator()</span>
<span class="hljs-attr">for</span> <span class="hljs-string">i in generator:</span>
    <span class="hljs-attr">print(i)</span>

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="生成器接收参数"></a><a href="#生成器接收参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成器接收参数</h3>
<p>生成器可以接收参数，从而改变自己的生成策略</p>
<pre><code class="hljs">def create_generator():
    msg = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>):
        msg = yield i ** msg
        <span class="hljs-keyword">if</span> msg <span class="hljs-keyword">is</span> None:
            msg = <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span>


generator = create_generator()
print(generator.__next__())  # 第一次调用时不可以传参，传参也只能是 None
print(generator.send(<span class="hljs-number">2</span>))  # <span class="hljs-number">3</span>^<span class="hljs-number">2</span> = <span class="hljs-number">9</span>
print(generator.send(<span class="hljs-number">3</span>))  # <span class="hljs-number">6</span>^<span class="hljs-number">3</span> = <span class="hljs-number">216</span>
</code></pre>
<p>输出</p>
<pre><code class="hljs"><span class="hljs-number">0</span>
<span class="hljs-number">9</span>
<span class="hljs-number">216</span>
</code></pre>
<blockquote>
<p>使用 send 来像生成器传参，传递的参数将会作为生成器内部的 yield i 的返回值</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="生成式迭代器"></a><a href="#生成式迭代器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成式迭代器</h3>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_generator</span></span>():
    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>):
        <span class="hljs-keyword">yield</span> i


gen1 = create_generator()
gen2 = (i * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i in gen1)
print(<span class="hljs-keyword">type</span>(gen2) == <span class="hljs-keyword">type</span>(gen1)) <span class="hljs-comment"># True</span>
</code></pre>
<blockquote>
<p>有点类似于生成式列表，只不过这里生成的是迭代器</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="总结"></a><a href="#总结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<ul>
<li>生成器可以当成一种迭代器</li>
<li>生成器机制使得迭代器更容易写，逻辑更简单</li>
<li>当我们要返回大量数据时，不妨使用生成器而不是一个list</li>
</ul>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 7/9/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#魔法方法">魔法方法</a></li><li><a href="#构造函数">构造函数</a><ul class="toc-headings"><li><a href="#继承时的调用">继承时的调用</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#元素访问">元素访问</a><ul class="toc-headings"><li><a href="#集合长度-len">集合长度 len</a></li><li><a href="#元素访问-1">元素访问</a></li><li><a href="#元素赋值">元素赋值</a></li><li><a href="#元素删除">元素删除</a></li><li><a href="#额外要求">额外要求</a></li></ul></li><li><a href="#get、set-属性方法">get、set 属性方法</a></li><li><a href="#静态方法和类方法">静态方法和类方法</a><ul class="toc-headings"><li><a href="#静态方法">静态方法</a></li><li><a href="#类方法">类方法</a></li></ul></li><li><a href="#访问对象属性">访问对象属性</a><ul class="toc-headings"><li><a href="#访问属性">访问属性</a></li><li><a href="#访问不存在的属性">访问不存在的属性</a></li><li><a href="#给属性赋值">给属性赋值</a></li><li><a href="#删除属性">删除属性</a></li></ul></li><li><a href="#迭代器协议">迭代器协议</a><ul class="toc-headings"><li><a href="#将可迭代对象转为-list">将可迭代对象转为 list</a></li></ul></li><li><a href="#生成器">生成器</a><ul class="toc-headings"><li><a href="#生成器接收参数">生成器接收参数</a></li><li><a href="#生成式迭代器">生成式迭代器</a></li><li><a href="#总结">总结</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>