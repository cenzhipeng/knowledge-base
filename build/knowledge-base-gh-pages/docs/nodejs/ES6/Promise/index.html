<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>本文内容 · 影子的知识库</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="本文主要记录 JavaScript 中的 Promise 与异步编程的相关内容，其中关系到 node.js 事件循环模型的内容，可以参考我之前写过的文章  [事件循环机制](/docs/nodejs/node基础/事件循环机制) "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="本文内容 · 影子的知识库"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.lovepp.org/"/><meta property="og:description" content="本文主要记录 JavaScript 中的 Promise 与异步编程的相关内容，其中关系到 node.js 事件循环模型的内容，可以参考我之前写过的文章  [事件循环机制](/docs/nodejs/node基础/事件循环机制) "/><meta property="og:image" content="https://www.lovepp.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://www.lovepp.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-153148512-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/js/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"scrollDuration":400}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/mark-github.svg" alt="影子的知识库"/><h2 class="headerTitleWithLogo">影子的知识库</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/JVM系列/JVM内存区域" target="_self">知识库</a></li><li class=""><a href="https://github.com/cenzhipeng/knowledge-base" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>ES6</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JVM系列<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/JVM系列/JVM内存区域">JVM内存区域</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/对象创建-布局-访问">对象创建-布局-访问</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存溢出实战">内存溢出实战</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/内存区域回收">内存区域回收</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/四大引用">四大引用</a></li><li class="navListItem"><a class="navItem" href="/docs/JVM系列/垃圾回收算法">垃圾回收算法</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Node<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">JS 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/语法基础和数据类型">语法基础和数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据类型转换">数据类型转换</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/语句-表达式-运算符">语句 表达式 运算符</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/变量与对象">变量与对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/数据处理">数据处理</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/常用API">常用 API</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/重点知识">重点知识</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/块级作用域">块级作用域</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/字符串和正则表达式">字符串和正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/函数">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/对象">对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Symbol">Symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/Set和Map">Set和Map</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/迭代器和生成器">迭代器和生成器</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/类">类</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/ES6/数组">数组</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nodejs/ES6/Promise">Promise</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Node 基础</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/模块系统">模块系统</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/package.json">package.json</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/内置对象">内置对象</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/npm脚本的使用">npm脚本的使用</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Buffer">Buffer</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/Stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/示例代码">示例代码</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">stream系列</h4><ul><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/流的缓冲">流的缓冲</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可读流">可读流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/可写流">可写流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/双工流和转换流">双工流和转换流</a></li><li class="navListItem"><a class="navItem" href="/docs/nodejs/node基础/stream系列/自定义流">自定义流</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">后期计划<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/后期计划/学习计划">学习计划</a></li><li class="navListItem"><a class="navItem" href="/docs/后期计划/专题研究计划">专题研究计划</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/cenzhipeng/knowledge-base/tree/master/docs/nodejs/ES6/Promise.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">本文内容</h1></header><article><div><span><p>本文主要记录 JavaScript 中的 Promise 与异步编程的相关内容，其中关系到 node.js 事件循环模型的内容，可以参考我之前写过的文章  <a href="/docs/nodejs/node基础/事件循环机制">事件循环机制</a></p>
<h2><a class="anchor" aria-hidden="true" id="回调地狱"></a><a href="#回调地狱" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调地狱</h2>
<p>回调地狱其实很容易理解，当我们使用回调函数时，我们有可能需要在任务1完成时开始任务2，任务2完成后执行任务3...这些任务的逻辑必须是有序的，那么我们的回调里面就会继续嵌套回调，一直套十几层也是常有的事，这就是回调地狱，Promise 就是来解决回调模式的局限性的</p>
<h2><a class="anchor" aria-hidden="true" id="promise"></a><a href="#promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise</h2>
<p>一个 Promise 就是一个异步操作的结果的占位符，它总共有 3 种状态</p>
<ul>
<li>pending：表示这个异步操作还在进行中，还未完成</li>
<li>fulfilled：表示这个异步操作已经完成并且获取了结果</li>
<li>rejected：表示这个异步操作失败了，出现了错误</li>
</ul>
<p>当我们使用 Promise 时，一个 Promise 从最开始的 pending，一直执行到 fulfilled 或者是 rejected。一旦执行到了 fulfilled 或者是 rejected，这个 Promise 的状态就不可改变了（因为内部的异步操作已经执行结束了，不论是执行完毕获取了结果，还是执行到一半出错，都算作执行结束）。</p>
<p>我们可以在一个 Promise 上定义后续的操作，后续的操作可以获取前面的异步操作的结果，这就是 Promise 真正的用处，可以用来定义一段连续的异步操作逻辑（使用回调模式的话，连续的异步操作必须写在一层一层的回调里）。</p>
<p>下面我们来看看例子</p>
<h2><a class="anchor" aria-hidden="true" id="fulfilled-状态"></a><a href="#fulfilled-状态" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>fulfilled 状态</h2>
<p>下面是一个最简单的例子</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">//异步操作</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">3</span>), <span class="hljs-number">2000</span>);
});

p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`获取id时间：<span class="hljs-subst">${process.uptime()}</span>，id：<span class="hljs-subst">${id}</span>`</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第一次输出时间：<span class="hljs-subst">${process.uptime()}</span>`</span>);
</code></pre>
<p>输出是</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
第一次输出时间：0.055265643
获取id时间：2.061154694，id：3
</code></pre>
<p>要点：</p>
<ul>
<li>当我们定义 <code>new Promise(function (resolve, reject){})</code> 时，就会立刻执行里面的这个函数</li>
<li>当里面的函数执行了 <code>resolve(xxx)</code> 时，就表示通知这个 Promise，说我这个异步操作完成了，此时这个 Promise 的状态就会改变成 fulfilled，表示异步操作完成</li>
<li>很显然，按照代码逻辑，一直到 2 秒后，才会执行 <code>resolve(xxx)</code> ，也就是说，这个 Promise 要 2 秒后才会进入 fulfilled 状态</li>
<li>当我们执行 <code>p1.then(function (id) {})</code> 时，p1 的状态依然是 pending，所以我们这句代码的真正含义是：当 p1 变成 fulfilled 状态时，执行这个回调函数</li>
<li>接下来我们输出一个日志，打印了一下时间</li>
<li>2 秒后，p1 终于完成了，并且获取到的结果是 3（<code>resolve(3)</code>），此时 p1 进入 fulfilled 状态</li>
<li>由于我们定义了 p1 后续的处理逻辑，因此，立刻执行 <code>function (id) {}</code>，这里的 id 就是 p1 最终的异步结果 3</li>
</ul>
<blockquote>
<p>这种构造函数的方式中，我们回调里必须调用 resolve，如果不调用 resolve，则不会进入 fulfilled 状态</p>
<p>如果也不调用 reject，则也不会进入 rejected 状态（如果抛出了错误则也会进入 rejected 状态），那么这个 Promise 将一直是 pending</p>
<p>在 then 方法中，如果不调用这两个函数执行结束了回调的话，默认当做执行了 resolve(undefined)，所以会进入 fulfilled 状态</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="rejected-状态"></a><a href="#rejected-状态" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>rejected 状态</h2>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">//异步操作</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'自定义的error'</span>)), <span class="hljs-number">2000</span>);
});

p1.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`执行出错时间：<span class="hljs-subst">${process.uptime()}</span>，错误信息：<span class="hljs-subst">${err.message}</span>`</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第一次输出时间：<span class="hljs-subst">${process.uptime()}</span>`</span>);
</code></pre>
<p>输出是</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
第一次输出时间：0.104552064
执行出错时间：2.106530248，错误信息：自定义的error
</code></pre>
<p>要点：</p>
<ul>
<li>当我们定义 <code>new Promise(function (resolve, reject){})</code> 时，就会立刻执行里面的这个函数</li>
<li>当里面的函数执行了 <code>reject(new Error('自定义的error'))</code> 时，就表示通知这个 Promise，说我这个异步操作出错了，此时这个 Promise 的状态就会改变成 rejected，表示异步操作出错了</li>
<li>很显然，2 秒后才会进入 rejected 状态</li>
<li>当我们执行 <code>p1.catch(function (err) {})</code> 时，Promise 的状态仍然是 pending，所以我们这句话的真正含义是：当 p1 变成 rejected 状态时，执行这个回调函数，里面的 err 参数，就是 p1 最终出错时候的那个错误</li>
<li>接下来我们输出一个日志，打印了一下时间</li>
<li>2 秒后，p1 终于出错了，错误对象是 <code>new Error('自定义的error')</code>， 此时 p1 进入 rejected 状态</li>
<li>由于我们定义了 p1 进入 rejected 的后续的处理逻辑，因此，立刻执行 <code>function (err) {}</code>，这里的 err 就是 p1 最终的错误对象</li>
</ul>
<blockquote>
<p>回调里调用 reject，或者是抛出了错误，就会进入 rejected 状态</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="多次处理同一个-promise"></a><a href="#多次处理同一个-promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多次处理同一个 Promise</h2>
<p>对于一个 Promise，我们可以进行多个后续的异步操作。</p>
<p>这种场景其实很常见，例如：我们通过网络获取了一个学生的ID，然后我们需要根据这个ID获取学生的姓名，还需要根据这个ID获取他的年龄，这两个信息可能来自两个接口，也就是我们需要发送 2 个请求，这就是 2 个后续的异步操作了，它们都需要第一个异步操作的结果，也就是请求获取到的学生的ID</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">//异步操作</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">3</span>), <span class="hljs-number">2000</span>);
});

p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`获取id时间：<span class="hljs-subst">${process.uptime()}</span>，id + 1 = <span class="hljs-subst">${id + <span class="hljs-number">1</span>}</span>`</span>);
});
p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`获取id时间：<span class="hljs-subst">${process.uptime()}</span>，id + 10 = <span class="hljs-subst">${id + <span class="hljs-number">10</span>}</span>`</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第一次输出时间：<span class="hljs-subst">${process.uptime()}</span>`</span>);
</code></pre>
<p>输出是</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
第一次输出时间：0.118611816
获取id时间：2.123034401，id + 1 = 4
获取id时间：2.123242512，id + 10 = 13
</code></pre>
<blockquote>
<p>可以看出来，这两个后续处理逻辑，都获取了上一步的异步结果，并且它们的执行顺序，就是我们定义的顺序</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="同时处理结果和异常"></a><a href="#同时处理结果和异常" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同时处理结果和异常</h2>
<p>一个异步操作，它的最终状态可能是顺利完成，也可能是出错了。</p>
<p>这个是很正常的，比如我们请求一个接口时，顺利完成的情况当然就是正常获取了接口返回的信息了，而出错的情况则很多了，比如服务器炸了、网络炸了等等。所以说，一个 Promise 最终要么会进入 fulfilled，要么进入 rejected 状态。我们一般需要同时处理这两个状态</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 随机 0 到 2 秒，1秒内则正常返回，1秒后则表示出错</span>
    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set timeout to: '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call resolve()...'</span>);
            resolve(<span class="hljs-string">'200 OK'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call reject()...'</span>);
            reject(<span class="hljs-string">'timeout in '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
        }
    }, timeOut * <span class="hljs-number">1000</span>);
});

p1.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败：'</span> + reason);
});
p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功：'</span> + result);
});
</code></pre>
<p>连续执行 2 次，输出如下</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
<span class="hljs-built_in">set</span> timeout to: 0.747976999086402 seconds.
call resolve()...
成功：200 OK

(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
<span class="hljs-built_in">set</span> timeout to: 1.8850179221911745 seconds.
call reject()...
失败：timeout <span class="hljs-keyword">in</span> 1.8850179221911745 seconds.
(node:17229) UnhandledPromiseRejectionWarning: timeout <span class="hljs-keyword">in</span> 1.8850179221911745 seconds.
(node:17229) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="hljs-keyword">function</span> without a catch block, or by rejecting a promise <span class="hljs-built_in">which</span> was not handled with .catch(). (rejection id: 1)
(node:17229) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="hljs-built_in">exit</span> code.
</code></pre>
<p>要点：</p>
<ul>
<li>我们对同一个 Promise 既调用了 catch，也调用了 then</li>
<li>当 Promise 顺利完成时，会忽略掉 catch，执行 then 里面的后续</li>
<li>当 Promise 出错了进入 rejected 时，会忽略掉 then，执行 catch 里面的后续</li>
<li>第二次调用时，Promise 进入 rejected，输出里有一些警告信息，这是因为 <code>p1.then(function (result) {})</code> ，它又新生成了一个 Promise，并且这个 Promise 最终的状态是 rejected，并且没有被使用 catch 捕获该错误</li>
</ul>
<p>所以我们最佳的方式是这样的</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 随机 0 到 2 秒，1秒内则正常返回，1秒后则表示出错</span>
    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set timeout to: '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call resolve()...'</span>);
            resolve(<span class="hljs-string">'200 OK'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call reject()...'</span>);
            reject(<span class="hljs-string">'timeout in '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
        }
    }, timeOut * <span class="hljs-number">1000</span>);
});


p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功：'</span> + result);
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败：'</span> + reason);
});
</code></pre>
<p>输出</p>
<pre><code class="hljs css language-javascript">(py3<span class="hljs-number">.5</span>) czp@:~<span class="hljs-regexp">/workspace/</span>knowledge-base/demos/node_start$ node hello.js
<span class="hljs-keyword">set</span> timeout to: 0.1580341394446627 seconds.
call resolve()...
成功：200 OK

(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
<span class="hljs-keyword">set</span> timeout to: 1.2513693174457026 seconds.
call reject()...
失败：timeout in 1.2513693174457026 seconds.
</code></pre>
<p>要点：</p>
<ul>
<li>这种链式调用的方式不会报错，因为我们最终捕获了该 rejected 的错误 (<code>p1.then.catch</code>)</li>
</ul>
<p>实际上，then 也可以同时接受 2 个参数，同时处理结果和异常</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 随机 0 到 2 秒，1秒内则正常返回，1秒后则表示出错</span>
    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set timeout to: '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call resolve()...'</span>);
            resolve(<span class="hljs-string">'200 OK'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call reject()...'</span>);
            reject(<span class="hljs-string">'timeout in '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
        }
    }, timeOut * <span class="hljs-number">1000</span>);
});


p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功：'</span> + result);
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败：'</span> + reason);
});
</code></pre>
<p>跟上面的结果是一样的</p>
<h2><a class="anchor" aria-hidden="true" id="then-和-catch"></a><a href="#then-和-catch" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>then 和 catch</h2>
<ul>
<li><p>then 方法接收 2 个参数，每个参数都是一个函数，第一个参数表示的是对 Promise 的结果的处理逻辑，第二个参数表示的是对 Promise 的错误的处理逻辑，这两个参数都是可选的。</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 随机 0 到 2 秒，1秒内则正常返回，1秒后则表示出错</span>
    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set timeout to: '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call resolve()...'</span>);
            resolve(<span class="hljs-string">'200 OK'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call reject()...'</span>);
            reject(<span class="hljs-string">'timeout in '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
        }
    }, timeOut * <span class="hljs-number">1000</span>);
});

p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功：'</span> + result);
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败：'</span> + reason);
});
</code></pre></li>
<li><p>catch 方法接收 1 个参数，这个参数是一个函数，表示的是对 Promise 的错误的处理逻辑，它的含义等同于 then 方法的第二个参数，只不过是一种语义更清晰的方式，也就是上述代码等同于下面的</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 随机 0 到 2 秒，1秒内则正常返回，1秒后则表示出错</span>
    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set timeout to: '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call resolve()...'</span>);
            resolve(<span class="hljs-string">'200 OK'</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'call reject()...'</span>);
            reject(<span class="hljs-string">'timeout in '</span> + timeOut + <span class="hljs-string">' seconds.'</span>);
        }
    }, timeOut * <span class="hljs-number">1000</span>);
});


p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功：'</span> + result);
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败：'</span> + reason);
});
</code></pre></li>
<li><p>then 方法会返回一个新的 Promise 对象，例如 <code>promise2 = promise1.then(onFulfilled, onRejected)</code> 具有以下的规则</p>
<ul>
<li><p>如果 <code>onRejected</code> 不是函数（或者说没传这个参数）且 <code>promise1</code> 拒绝执行， <code>promise2</code> 会拒绝执行并返回相同的据因（这也就是我们之前的例子中，单独对一个最终会拒绝执行的 promise 进行单个参数的 then 调用时，最后会返回警告我们没有捕获错误的原因）</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(error));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-string">'x'</span>);
p2.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err === error); <span class="hljs-comment">// 将会输出 true，表示输出同一个错误</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 会成功执行并返回相同的值，例如 <code>promise2 = promise1.then('hhh')</code>，这里的 <code>'hhh'</code> 不是函数，将会被替换成一个函数：<code>(value) =&gt; value</code>，也就是原样返回</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-string">'hhh'</span>);
p2.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 将会输出 3</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，返回了一个值，那么 <code>promise2</code> 将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value + <span class="hljs-number">10</span>);
p2.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 将会输出 13</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，没有返回值，那么 <code>promise2</code> 将会成为接受状态，并且 <code>promise2</code> 的结果就是 undefined</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 没有返回值</span>
});
p2.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 将会输出 undefined</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，抛出一个错误，那么 <code>promise2</code> 将会成为拒绝状态，并且 <code>promise2</code> 的拒绝原因就是这个错误</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 抛出错误</span>
    <span class="hljs-keyword">throw</span> error;
});
p2.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err === error);  <span class="hljs-comment">// 将会输出 true</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，返回一个已经是接受状态的 Promise，那么 <code>promise2</code> 将会成为接受状态，并且 <code>promise2</code> 的结果值就是这个回调里返回 Promise 的结果</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 返回一个已经是接受状态的 Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-number">100</span>));
});
p2.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 将会输出 100</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，返回一个已经是拒绝状态的 Promise，那么 <code>promise2</code> 将会成为拒绝状态，并且 <code>promise2</code> 的错误原因就是这个回调里返回 Promise 的错误原因</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 返回一个已经是拒绝状态的 Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejected</span>) =&gt;</span> rejected(error));
});
p2.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err === error);  <span class="hljs-comment">// 将会输出 true</span>
});
</code></pre></li>
<li><p>如果 <code>onFulfilled, onRejected</code> 最终执行的那个回调，返回一个 pending 状态的 Promise，那么 <code>promise2</code> 将会成为 pending 状态，并且 <code>promise2</code> 的最终状态就是这个回调里返回 Promise 的最终状态</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 返回一个 pending 状态的 Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">200</span>), <span class="hljs-number">300</span>);
    });
});
p2.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 将会输出 200</span>
});
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'同一个错误'</span>);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-comment">// 返回一个 pending 状态的 Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejected</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> rejected(error), <span class="hljs-number">300</span>);
    });
});
p2.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err === error);  <span class="hljs-comment">// 将会输出 true</span>
});
</code></pre>
<blockquote>
<p>说白了，如果 then 方法的回调函数里返回 Promise（或者是 Thenable 对象），那么 then 方法返回的 Promise 与之等价（但并不是同一个 Promise 对象）</p>
<p>这样一来，我们就可以进行一个链式的异步调用，Promise1 返回 Promise2，Promise2 返回 Promise3，这样就将几个异步操作串联起来，定义了一个异步的执行顺序（比如这个举例中，最后的顺序一定是 Promise1 --&gt; Promise2 --&gt; Promise3，这三个异步操作的顺序是明确的，但是具体的执行时间点是不确定的）</p>
</blockquote></li>
</ul></li>
<li><p>catch 方法也会返回一个新的 Promise 对象，它的行为与 then 方法基本相同，唯一的区别是这个方法只处理 rejected 状态的 Promise</p></li>
<li><p>实际上 <code>obj.catch(onRejected)</code> 完全等价于 <code>obj.then(undefined, onRejected)</code>，catch 只是一种更加语义化的方法</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="resolve-和-reject"></a><a href="#resolve-和-reject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>resolve 和 reject</h2>
<p>创建 Promise 的语法是</p>
<p><code>new Promise( function(resolve, reject) {...} /* executor */ );</code></p>
<ul>
<li><p>resolve：回调函数中，resolve 被调用时，将这个 Promise 的状态改为 fulfilled</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>)); <span class="hljs-comment">// fulfilled</span>
</code></pre></li>
<li><p>reject：回调函数中，reject 被调用时，将这个 Promise 的状态改为 rejected</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">''</span>))); <span class="hljs-comment">// rejected</span>
</code></pre></li>
<li><p>参数：传递给 resolve 和 reject 函数的参数，将会分别作为 fuiflled 和 rejected 状态的处理函数的参数</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(<span class="hljs-number">3</span>));
p1.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 3</span>
})
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-number">3</span>));
p1.catch(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 3</span>
})
</code></pre></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="创建-promise"></a><a href="#创建-promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 Promise</h2>
<h3><a class="anchor" aria-hidden="true" id="通用方式"></a><a href="#通用方式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通用方式</h3>
<p><code>new Promise( function(resolve, reject) {...} /* executor */ );</code></p>
<p>我们在回调里调用 resolve 还是 reject，决定 Promise 最终是 fulfilled 还是 reject 状态。</p>
<h3><a class="anchor" aria-hidden="true" id="promiseresolve"></a><a href="#promiseresolve" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise.resolve()</h3>
<p>通过这种方式直接创建一个 fulfilled 的 Promise</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">44</span>);
p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 44</span>
});
</code></pre>
<p>可以看到，我们直接创建了一个完成状态的 Promise</p>
<h3><a class="anchor" aria-hidden="true" id="promiserejected"></a><a href="#promiserejected" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise.rejected()</h3>
<p>通过这种方式直接创建一个 rejected 的 Promise</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'自定义错误'</span>));
p.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err.message); <span class="hljs-comment">// 自定义错误</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="非-promise-的-thenable-对象"></a><a href="#非-promise-的-thenable-对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非 Promise 的 Thenable 对象</h3>
<p>拥有 then 方法，并且接收 resolve 和 reject 两个函数的对象就是 Thenable 对象（鸭子类型），例如</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> thenable = {
    then(resolve, reject) {
        resolve(<span class="hljs-number">42</span>);
    }
};
<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(thenable);
p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value);
});
</code></pre>
<blockquote>
<p>这里的逻辑就是返回了一个跟 thenable 等价的 Promise，类似于 then 方法的回调里返回 Promise 一样</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="串联-promise"></a><a href="#串联-promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>串联 Promise</h2>
<p>Promise 最大的价值就是定义了异步操作的执行顺序，这在以前只能通过回调里嵌套回调来定义，下面我写一个例子，模拟一些常见的逻辑：先请求一个 URL 去获取一个用户的ID，根据用户ID，去请求另一个 URL，获取用户的名称</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserID</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-number">100</span>);
        }, <span class="hljs-number">200</span>); <span class="hljs-comment">// 模拟一个异步请求，0.2秒后获取到一个 user id</span>
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserNameByID</span>(<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`czp:<span class="hljs-subst">${id}</span>`</span>);
        }, <span class="hljs-number">200</span>); <span class="hljs-comment">// 模拟一个异步请求，0.2秒后获取到一个 user name</span>
    });
}

<span class="hljs-keyword">let</span> p1 = getUserID();
p1.then(getUserNameByID)
    .then(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// czp:100</span>
    });
</code></pre>
<p>可以看到，Promise 被串联了起来，一个 Promise 返回另一个 Promise，然后等第一个执行完毕了才执行第二个</p>
<blockquote>
<p>最好在最后加上一个 Promise 的 catch 方法进行错误处理</p>
</blockquote>
<p>这种模式让我们定义了一个个异步操作的顺序，在以后会非常有用，比如我们想写完第一个文件后才写第二个文件，然后才写第三个文件，这种有严格顺序要求的时候，就需要用到这种模式</p>
<h2><a class="anchor" aria-hidden="true" id="响应多个-promise"></a><a href="#响应多个-promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>响应多个 Promise</h2>
<h3><a class="anchor" aria-hidden="true" id="promisealliterable"></a><a href="#promisealliterable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise.all(iterable)</h3>
<p>返回一个 Promise，当迭代器里的所有 Promise 都完成时，这个 Promise 才完成。如果迭代器中有任意一个 Promise 最终是 rejected 状态，那么这个返回的 Promse 就是 rejected 状态，失败原因的是第一个失败 <code>promise</code> 的原因，值是所有的值组成的数组</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">33</span>);
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">333</span>);
<span class="hljs-keyword">let</span> p4 = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);
p4.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// [ 3, 33, 333 ]</span>
});
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">33</span>);
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">333</span>);
<span class="hljs-keyword">let</span> p4 = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);
p4.catch(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 输出 333</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="promiseanyiterable-实验性功能"></a><a href="#promiseanyiterable-实验性功能" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise.any(iterable) <strong>实验性功能</strong></h3>
<p>返回一个 Promise，当迭代器里的任意一个 Promise 完成时，这个 Promise 就完成，并且就是那个已完成的 Promise。如果迭代器中所有 Promise 最终都是 rejected 状态，那么这个返回的 Promse 就是 rejected 状态，失败原因就是所有错误组成的错误数组，本质上来说就是 <code>Promise.all</code> 的反义词</p>
<blockquote>
<p>这个方法在浏览器中尚未完全支持，所以最好还是别用，用下面的 Promise.race 方法</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="promiseraceiterable"></a><a href="#promiseraceiterable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise.race(iterable)</h3>
<p>返回一个 Promise，一旦迭代器中的某个 Promise 解决或拒绝，返回的 Promise就会解决或拒绝。（也就是返回一个与<strong>最先完成或者拒绝的 Promise</strong> 等价的 Promise）</p>
<p>也就是说，有点类似于 any，但是并不完全与 all 相反</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">33</span>);
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">333</span>);
<span class="hljs-keyword">let</span> p4 = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);
p4.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 输出 3</span>
});
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">33</span>);
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">333</span>);
<span class="hljs-keyword">let</span> p4 = <span class="hljs-built_in">Promise</span>.race([p3, p1, p2]);
p4.catch(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 输出 333</span>
});
</code></pre>
<blockquote>
<p>注意 2 段代码里传入的 p1,p2,p3 的顺序</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="async-和-await"></a><a href="#async-和-await" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async 和 await</h2>
<p>ES 7 标准，添加了 async 和 await 关键字，这两个关键字涵盖了异步编程的功能，它们与 Promise 相辅相成，简化了 Promise 的使用，但本质还是 Promise</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'resolved'</span>);
        }, <span class="hljs-number">2000</span>);
    });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCall</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'calling'</span>);
    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> resolveAfter2Seconds();
    <span class="hljs-built_in">console</span>.log(result);
    <span class="hljs-comment">// expected output: 'resolved'</span>
}

asyncCall();
</code></pre>
<p>输出</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
calling
resolved
</code></pre>
<p>要点：</p>
<ul>
<li><p>async 定义的函数叫做异步函数，执行这个函数后，将会返回一个 Promise</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{

}
<span class="hljs-built_in">console</span>.log(test() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>); <span class="hljs-comment">// true</span>
</code></pre></li>
<li><p>await 关键字只能在 async 定义的异步函数中使用，在其它地方使用将会报错</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'resolved'</span>);
        }, <span class="hljs-number">2000</span>);
    });
}
<span class="hljs-keyword">await</span> resolveAfter2Seconds();
<span class="hljs-comment">// 以上将会报错</span>
</code></pre></li>
<li><p>await 后面如果接收的是一个 Promise 对象，则将会等待该 Promise 完成（接受或者拒绝），也就是说，<code>await promise</code> 将会获取到这个 promise 的结果</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'resolved'</span>);
        }, <span class="hljs-number">2000</span>);
    });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCall</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> resolveAfter2Seconds();
    <span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// resolved</span>
}

asyncCall();
</code></pre></li>
<li><p><code>var result = await resolveAfter2Seconds();</code> 这里就获取到了 promise 的结果 <code>resolve('resolved');</code>，也就是字符串 <code>resolved</code></p>
<blockquote>
<p>参考上面的例子</p>
</blockquote></li>
<li><p>实际上来说，<code>await promise</code> 定义了一个语义：外层的异步函数执行到这里将会停止，直到这个内层 promise 执行完成，这样就相当于确定了 2 个 promise 的执行顺序</p></li>
<li><p>异步函数内部抛出错误，这个异步函数返回的 Promise 将会进入 rejected 状态</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'出错了'</span>);
}

test().catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err.message); <span class="hljs-comment">// 出错了</span>
});
</code></pre></li>
<li><p>异步函数内部返回了一个值，这个值就是返回的 Promise 的最终的结果值</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">333</span>
}

test().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 333</span>
});
</code></pre></li>
</ul>
<blockquote>
<p>可以看出来，这种 async 和 await 就是语法糖，本质还是 Promise</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="并行和串行"></a><a href="#并行和串行" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>并行和串行</h3>
<p>使用 async 和 await 很容易就可以达到串行的目的</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> resolveAfter2Seconds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`slow promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-keyword">let</span> resolveAfter1Second = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`fast promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">1000</span>);
    });
};

<span class="hljs-keyword">let</span> sequentialStart = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> slow = <span class="hljs-keyword">await</span> resolveAfter2Seconds();
    <span class="hljs-built_in">console</span>.log(slow); <span class="hljs-comment">// 执行到这里时，已经经过了 2 秒</span>

    <span class="hljs-keyword">const</span> fast = <span class="hljs-keyword">await</span> resolveAfter1Second();
    <span class="hljs-built_in">console</span>.log(fast); <span class="hljs-comment">// 执行到这里时，又经过了 1 秒，也就是此刻是 3 秒</span>
};
sequentialStart();
</code></pre>
<p>输出</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
slow promise is <span class="hljs-keyword">done</span> at : 2.043946858
fast promise is <span class="hljs-keyword">done</span> at : 3.057041464
</code></pre>
<blockquote>
<p>这里，我们 sequentialStart 方法中，执行第一个 Promise 时，第二个 Promise 并没有被调用，所以都没有开始执行，所以当我们执行第二个 Promise 时，还需要再等待 1 秒</p>
</blockquote>
<p>下面看看如何来定义并行的逻辑</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> resolveAfter2Seconds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`slow promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-keyword">let</span> resolveAfter1Second = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`fast promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">1000</span>);
    });
};

<span class="hljs-keyword">let</span> concurrentStart = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> slowPromise = resolveAfter2Seconds();
    <span class="hljs-keyword">const</span> fastPromise = resolveAfter1Second();
    <span class="hljs-comment">// 以上同时启动了 2 个 Promise</span>
    <span class="hljs-keyword">const</span> slow = <span class="hljs-keyword">await</span> slowPromise;
    <span class="hljs-built_in">console</span>.log(slow);
    <span class="hljs-comment">// 执行到这里时，已经经过了 2 秒，此时 slowPromise 已经完成了</span>
    <span class="hljs-comment">// 同时，此时 fastPromise 也已经完成了，因为它 2 秒前就启动了，而完成它只需要 1 秒</span>
    <span class="hljs-keyword">const</span> fast = <span class="hljs-keyword">await</span> fastPromise; <span class="hljs-comment">// 这一行代码瞬间就返回了，因为 fastPromise 早就返回了</span>
    <span class="hljs-built_in">console</span>.log(fast);
};
concurrentStart();
</code></pre>
<p>输出</p>
<pre><code class="hljs css language-bash">(py3.5) czp@:~/workspace/knowledge-base/demos/node_start$ node hello.js
slow promise is <span class="hljs-keyword">done</span> at : 2.050631249
fast promise is <span class="hljs-keyword">done</span> at : 1.047641309
</code></pre>
<p>换一种方式</p>
<pre><code class="hljs css language-javas"><span class="hljs-keyword">let</span> resolveAfter2Seconds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`slow promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-keyword">let</span> resolveAfter1Second = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">`fast promise is done at : <span class="hljs-subst">${process.uptime()}</span>`</span>);
        }, <span class="hljs-number">1000</span>);
    });
};

<span class="hljs-keyword">let</span> concurrentStart = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([
        <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-params"><span class="hljs-keyword">await</span> resolveAfter2Seconds(<span class="hljs-params"></span>)</span>)</span>)<span class="hljs-params">()</span>,
        (<span class="hljs-params"><span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-params"><span class="hljs-keyword">await</span> resolveAfter1Second(<span class="hljs-params"></span>)</span>)</span>)<span class="hljs-params">()</span>
    ])
};
<span class="hljs-params">concurrentStart</span><span class="hljs-params">()</span>;
</span></code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 1/16/2020</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/nodejs/ES6/数组"><span class="arrow-prev">← </span><span>数组</span></a><a class="docs-next button" href="/docs/nodejs/node基础/模块系统"><span>模块系统</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#回调地狱">回调地狱</a></li><li><a href="#promise">Promise</a></li><li><a href="#fulfilled-状态">fulfilled 状态</a></li><li><a href="#rejected-状态">rejected 状态</a></li><li><a href="#多次处理同一个-promise">多次处理同一个 Promise</a></li><li><a href="#同时处理结果和异常">同时处理结果和异常</a></li><li><a href="#then-和-catch">then 和 catch</a></li><li><a href="#resolve-和-reject">resolve 和 reject</a></li><li><a href="#创建-promise">创建 Promise</a><ul class="toc-headings"><li><a href="#通用方式">通用方式</a></li><li><a href="#promiseresolve">Promise.resolve()</a></li><li><a href="#promiserejected">Promise.rejected()</a></li><li><a href="#非-promise-的-thenable-对象">非 Promise 的 Thenable 对象</a></li></ul></li><li><a href="#串联-promise">串联 Promise</a></li><li><a href="#响应多个-promise">响应多个 Promise</a><ul class="toc-headings"><li><a href="#promisealliterable">Promise.all(iterable)</a></li><li><a href="#promiseanyiterable-实验性功能">Promise.any(iterable) <strong>实验性功能</strong></a></li><li><a href="#promiseraceiterable">Promise.race(iterable)</a></li></ul></li><li><a href="#async-和-await">async 和 await</a><ul class="toc-headings"><li><a href="#并行和串行">并行和串行</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/mark-github.svg" alt="影子的知识库" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/docs/en/doc2.html">Guides (or other categories)</a><a href="/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2020 Cen ZhiPeng</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'QY49S75304',
                apiKey: '411affb22749e84f2506f330ffac2fba',
                indexName: 'knowledge_base',
                inputSelector: '#search_input_react'
              });
            </script></body></html>